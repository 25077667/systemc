Development process of the Accellera SystemC implementation
===========================================================
v0.9, September 2012

In this document, the internal development process for Accellera's SystemC
Language Working Group (and TLM Working Group) is described.  This mostly
relates to the development and maintenance procedures for the ASI
proof-of-concept implementation of SystemC (and TLM).  This document
focuses on the technical aspects related to the development of the ASI
SystemC implementation.  Legal and formal procedures are documented at
<http://accellera.org>.


---------------------------------------------------------------------
Repository organization
---------------------------------------------------------------------

The central source code repository of the ASI SystemC implementation is
hosted in two Git [1] repositories at [GitHub](http://github.com).  The
repositories are private to the `OSCI-WG` organization and can be found at:

 * <http://github.com/OSCI-WG/systemc>             (core SystemC library)
 * <http://github.com/OSCI-WG/systemc-regressions> (regression test suite)

Members of the `OSCI-WG` organization with the necessary access rights can
clone the repositories via SSH from the locations

>    git clone git@github.com:OSCI-WG/systemc.git
>    git clone git@github.com:OSCI-WG/systemc-regressions.git

respectively.  To obtain access to the repositories and the GitHub
organization in general, LWG members can contact the LWG chairs at
<mailto:lwg-chair@lists.accellera.org> including their GitHub account name.

Comprehensive documentation about [Git] [1], a distributed version control
system, can be found in the [Pro Git book] [2], also available online.
Since Git is 'distributed', it is a very natural choice for the distributed
development process needed for the collaboratively evolving proof-of-concept
implementation of SystemC.

In order to contribute changes to the different repositories, it is
recommended to create personal (or company-based) [forks] [3] of the
repositories on GitHub and push the proposed changes (bugfixes,
features, ...) there.  These forks are also only accessible to members
of the OSCI-WG organization. Details of the intended work-flow are
described in the next [section](#sec:branching). It is convenient to
add this GitHub fork as a remote to your local clone of the
repository:

>    cd <repo>/
>    git remote add github git@github.com:<your-account>/<repo>.git

Any changes can be then pushed to GitHub using:

>    git push github <local-branch>:<remote-branch>


[1]: http://git-scm.com "Git version control system"
[2]: http://git-scm.com/book "Pro Git Book"
[3]: https://help.github.com/articles/fork-a-repo


---------------------------------------------------------------------
<a id="sec:branching" />
Development flow
---------------------------------------------------------------------

### Basic branch setup

The main idea is to have two main branches, one for the development,
one for the releases.

* **master**

  The latest and greatest `HEAD` of the LWG development.
  This is, were all the new features and fixes go.

* **release**

  This branch is used to create the release tar balls, both
  internal and public snapshots.

For the **regressions**, the `release` branch is more or less just a pointer
to the latest revision of a snapshot (or release).  It is still useful
to keep a named branching point, in case of required hotfixes.

For the **core library**, the `release` branch is to be different from the
`master` branch.  The idea is to fully track the contents of the released
tar ball.  This means

  - The Automake generated files are added to this tree.
  - ASI internal files are stripped
    (`.gitignore`, internal documentation, ...).

To prepare a release, the `master` branch would then be merged into the
`release` branch, the automake files would be updated (if necessary) and
the clean working tree could be used as baseline for the tar ball (e.g.,
via `git-archive(1)`).  Details are described in the next section
[release management](#sec:release).

Based on these branches, a development model similar to the well-known
["successful branching model"] [4] can be deployed.  Not all aspects of this
model are needed for the ASI SystemC implementation, as we usually maintain
only a single (i.e., the latest) release of the kernel.


[4]: http://nvie.com/posts/a-successful-git-branching-model/
     "'A successful Git branching model' by Vincent Driessen"


<a id="sec:feature-branch" />
### Adding a feature (set) or fixing a bug

The development of a new contribution in form of a feature or a bug
fix is best done in a new feature branch, wich is forked and checked
out from the ASI `master` branch:

>    git checkout -b <company>-<feature-xyz>

Then code up the new contribution. Please try to facilitate code
review by other ASI members by logically grouping your changes into
one commit per addressed issue. For the commit messages, please
consider to follow these suggestions: 

>  *Note:* **Commit messages**
>
>  Though not required, itâ€™s a good idea to begin the commit message with
>  a single short (less than 50 character) line summarizing the change,
>  followed by a blank line and then a more thorough description. Tools
>  that turn commits into email, for example, use the first line on the
>  `Subject:` line and the rest of the commit in the body.

During the development of the contribution, the `master` branch may
receive other commits. In that case, consider to rebase the commits in
your feature branch onto the `HEAD` of the `master` branch to keep the
history clean. Once the contribution is ready for review by the
working group, push the feature branch in your fork of the respective
repository on GitHub:

> git push <your-github-fork-remote-name> <company>-<feature-xyz>

Then, send a pull request either manually or via GitHub to initiate
the code review by the working group members. In case the contribution
is accepted, it will be merged into the ASI `master` branch by the
responsible source code maintainer. Instead of fully merging the
contribution, the maintainer may choose to cherry pick individual
commits or to rebase the feature branch on an intermittently updated
`master`. He may also request additional changes to be done by the
submitter. In that case, the submitter may need to merge recent
changes to the `master` branch into his feature branch before carrying
out the requested changes.

After the contribution has been fully merged into `master`, the
feature branch in the local and Github fork may be deleted.


### Tracking release tar balls

In order to track the release tar balls (both LWG-internal and public
ones), a tool named [`pristine-tar`] [5] is used.  It enables to track
archives directly within the repository.

When looking at the branches (e.g., by using `gitk --all`), you may notice
an additional, separate branch called `pristine-tar`.  This branch contains
the metadata for the pristine-tar tool.  `pristine-tar` enables
tracking original archives with minimal overhead, since only small binary 
deltas instead of the full tar balls are stored within the repository.

> *NOTE*: Currently, only Linux (and recently Mac OS X) are supported
>         platforms for `pristine-tar`.  Porting to Windows (MinGW) is
>         to be done in the future, which should be possible with
>         reasonable effort to support the required use cases within
>         the ASI SystemC working groups.


#### Basic workflow

>     # adding an archive
>     pristine-tar [-m message] commit systemc-2.3.1.tgz release
>     git push origin pristine-tar
> 
>     # retrieving an archive
>     pristine-tar checkout systemc-2.3.1.tgz


The maintenance of the `pristine-tar` branch (i.e., adding new archives to
the `pristine-tar` branch) is done by the LWG chairs during the [release
management](#sec:release).


[5]: http://joeyh.name/code/pristine-tar/ "pristine-tar homepage"


### Maintaining a private (set of) branches

*TODO*: Outline maintenance of an in-house forking model, seamlessly
        integrated with the LWG's flow.

Vendor's may be interested in maintaining their own, in-house flow
to align the internal development of a derived SystemC implementation,
while being able to pick fixes from the ASI tree (and hopefully)
contributing fixes and features back to the proof-of-concept
implementation.

For this purpose members may employ the already mentioned ["successful
branching model"] [4] by Vincent Driessen. The vendor can branch its
own development branch, e.g., `develop-<vendor>` from the already
tracked ASI's development branch `master` in his clone of the ASI
repository. The vendor is then able to integrate commits on the ASI
development branch by merging it into his his vendor development
branch.

Bug fixes to be contributed back to ASI consist usually of one or
several isolated commits. They need to be cherry picked from the
vendor's development branch into a new branch created from the ASI
development branch:

>    git checkout -b <vendor>-fix-<bug> origin/master
>    git cherry-pick <commit>...

Once, the bug fix branch is ready, it should be pushed into the
vendor's github account and a pull request created, as described in
the [feature branch section](#sec:feature-branch).

A new feature consists usually of a series of commits developed in a
dedicated feature branched of the vendor's or ASI's development
branch. Only in the first case, a rebase on the top of the ASI's
development branch is necessary. To this end, branch first from the
feature branch:

>    git checkout -b <vendor>-<new-feature> <private-feature-branch>
>    git rebase [-i|--interactive] --onto origin/master develop-<vendor>

Once, the bug fix branch is ready, it should be pushed into the
vendor's github account and a pull request created, as described in
the [feature branch section](#sec:feature-branch).


---------------------------------------------------------------------
<a id="sec:release" />
Release management
---------------------------------------------------------------------

*TODO*: write documentation how to generate release tar balls.

* `git checkout release`
* `git merge    master`
* Remove any internal documents, not meant for release.
* `autoreconf -f` or `config/bootstrap`
* Check `git status`, commit new and updated automake files.
* Use `git archive` to create the release tar balls, e.g.:

    git archive --format=tar --prefix=systemc-<version>/ HEAD | bzip2 > systemc-<version>.tar.bz2
    git archive --format=tar --prefix=systemc_tests-<version>/ HEAD | bzip2 > systemc_tests-<version>.tar.bz2
    git archive --format=tar.gz --prefix=systemc-<version>/ HEAD  systemc-<version>.tar.gz
    git archive --format=zip --prefix=systemc-<version>/ HEAD systemc-<version>.zip

* The `<version` mentioned in the release tar ball name should follow
one of the three standard formats:

  * `x.x.x_<isodate>_beta` for beta versions
  * `x.x.x_<isodate>_pub_rev` for public review versions, and
  * `x.x.x` for final release versions.

* The name of the generated archive excluding its file type extension
  is used to tag the commit on the `master` branch from which was last
  merged to prepare the release.


---------------------------------------------------------------------
Issue tracking
---------------------------------------------------------------------

*TODO*: add issue tracking details

 * Use GitHub issue tracker
 * Define tags for severities and categories
 * Use pull-requests


---------------------------------------------------------------------
Changelog
---------------------------------------------------------------------

* v0.9 - Initial proposal to the ASI LWG (2012-09-04)

 * Presented and discussing during the LWG phone conference


---------------------------------------------------------------------
Authors
---------------------------------------------------------------------

  * Philipp A. Hartmann <philipp.hartmann@offis.de>
  * Torsten Maehne      <Torsten.Maehne@lip6.fr>

