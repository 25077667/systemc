.TH "tlm_initiator_port" 3 "17 Oct 2007" "Version 1" "TLM 2" \" -*- nroff -*-
.ad l
.nh
.SH NAME
tlm_initiator_port \- Class \fBtlm_initiator_port\fP: port to be instantiated on the initiator side.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <tlm_initiator_port.h>\fP
.PP
Inherits \fBtlm_initiator_port_base\fP.
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBtlm_initiator_port\fP (const char *name)"
.br
.in -1c
.PP
.RI "\fBsc_port overridden methods\fP"
.br
Need to specialize binding operation to support port propagation in transaction recorders. Specialization is done for sc_port/sc_port and sc_port/sc_export Other redefinitions of bindings are just calls to regular bind function 
.br
 Note: This is due to non virtual definition of SystemC bind method 
.PP
.in +1c
.in +1c
.ti -1c
.RI "void \fBbefore_end_of_elaboration\fP ()"
.br
.ti -1c
.RI "void \fBend_of_elaboration\fP ()"
.br
.ti -1c
.RI "void \fBbind\fP (\fBtarget_port_type\fP &target_port_)"
.br
.RI "\fIbind(sc_export) overridden with port registration \fP"
.ti -1c
.RI "template<typename OTHER_IF> void \fBbind\fP (\fBtlm_target_port\fP< OTHER_IF > &target_port_)"
.br
.RI "\fICase of the other port uses another interface as template: works only if OTHER_IF derives from IF. \fP"
.ti -1c
.RI "void \fBoperator()\fP (\fBtarget_port_type\fP &target_port_)"
.br
.RI "\fIoperator() (sc_export) overridden with port registration \fP"
.ti -1c
.RI "template<typename OTHER_IF> void \fBoperator()\fP (\fBtlm_target_port\fP< OTHER_IF > &target_port_)"
.br
.RI "\fICase of the other port uses another interface as template: works only if OTHER_IF derives from IF. \fP"
.ti -1c
.RI "void \fBbind\fP (sc_port_b< \fBinterface_type\fP > &port_)"
.br
.RI "\fIbind(sc_port) overridden with port registration \fP"
.ti -1c
.RI "void \fBoperator()\fP (sc_port_b< \fBinterface_type\fP > &port_)"
.br
.RI "\fIoperator() (sc_port) overridden with port registration \fP"
.ti -1c
.RI "void \fBbind\fP (\fBinterface_type\fP &interface_)"
.br
.RI "\fIbind(interface_type) overridden with port registration \fP"
.ti -1c
.RI "void \fBoperator()\fP (\fBinterface_type\fP &interface_)"
.br
.RI "\fIoperator () (interface_type) overridden with port registration \fP"
.in -1c
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "bool \fBis_interface_bound_twice\fP (sc_export_base &target_port_)"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "typedef IF \fBinterface_type\fP"
.br
.ti -1c
.RI "typedef \fBtlm_target_port\fP< IF > \fBtarget_port_type\fP"
.br
.ti -1c
.RI "typedef \fBtlm_initiator_port\fP< IF, N > \fBinitiator_port_type\fP"
.br
.ti -1c
.RI "typedef \fBtlm_target_port_base\fP \fBtarget_port_base_type\fP"
.br
.ti -1c
.RI "typedef \fBtlm_initiator_port_base\fP \fBinitiator_port_base_type\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename IF, int N = 1> class tlm_initiator_port< IF, N >"
Class \fBtlm_initiator_port\fP: port to be instantiated on the initiator side. 

This class could be used as base class for user defined initiator ports (support of user convenience layer). 
.br
 It provides new binding methods definition:
.IP "\(bu" 2
sc_port to sc_export binding must be identified in order to create target_port_list used for port ID propagation through hierarchical binding.
.IP "\(bu" 2
sc_port to sc_port binding creates two initiator ports lists: one regular list (deep port 'knows' other initiator ports through a hierarchy) and a reversed list (the port directly bound to the interface 'knows' deeper ports through a hierarchy) used to convey target_port list to deeper ports for target port ID propagation. An error detection is also provided: When the same interface is bound two times to a sc_port, SystemC causes the simulation end. This case could append in test platform (dedicated debug and regular port of a target bound to the same router). The specific binding issues a warning message but let the simulation run. 
.PP

.PP
Definition at line 50 of file tlm_initiator_port.h.
.SH "Member Typedef Documentation"
.PP 
.SS "template<typename IF, int N = 1> typedef IF \fBtlm_initiator_port\fP< IF, N >::\fBinterface_type\fP\fC [private]\fP"
.PP
Definition at line 54 of file tlm_initiator_port.h.
.SS "template<typename IF, int N = 1> typedef \fBtlm_target_port\fP<IF> \fBtlm_initiator_port\fP< IF, N >::\fBtarget_port_type\fP\fC [private]\fP"
.PP
Reimplemented from \fBtlm_initiator_port_base\fP.
.PP
Definition at line 55 of file tlm_initiator_port.h.
.SS "template<typename IF, int N = 1> typedef \fBtlm_initiator_port\fP<IF,N> \fBtlm_initiator_port\fP< IF, N >::\fBinitiator_port_type\fP\fC [private]\fP"
.PP
Definition at line 56 of file tlm_initiator_port.h.
.SS "template<typename IF, int N = 1> typedef \fBtlm_target_port_base\fP \fBtlm_initiator_port\fP< IF, N >::\fBtarget_port_base_type\fP\fC [private]\fP"
.PP
Definition at line 58 of file tlm_initiator_port.h.
.SS "template<typename IF, int N = 1> typedef \fBtlm_initiator_port_base\fP \fBtlm_initiator_port\fP< IF, N >::\fBinitiator_port_base_type\fP\fC [private]\fP"
.PP
Definition at line 59 of file tlm_initiator_port.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename IF, int N> \fBtlm_initiator_port\fP< IF, N >::\fBtlm_initiator_port\fP (const char * name)\fC [inline]\fP"
.PP
Definition at line 158 of file tlm_initiator_port.h.
.SH "Member Function Documentation"
.PP 
.SS "template<typename IF, int N> void \fBtlm_initiator_port\fP< IF, N >::before_end_of_elaboration ()\fC [inline]\fP"
.PP
Called just before end of elaboration to propagate registered target ports to all the bound initiator ports (using the reversed initiator port list).
.PP
Remark: sc_port_base::complete_binding should be the best place to do that but this method is private !! 
.PP
Definition at line 198 of file tlm_initiator_port.h.
.PP
References tlm_initiator_port_base::create_port_list(), tlm_initiator_port_base::get_reversed_initiator_port_list(), tlm_initiator_port_base::m_target_port_list, and tlm_initiator_port_base::set_initiator_port_list().
.SS "template<typename IF, int N> void \fBtlm_initiator_port\fP< IF, N >::end_of_elaboration ()\fC [inline]\fP"
.PP
Called at the end of elaboration. Checks target port list: empty target port list is a fatal error as initiator port should be bound at least to one target_port 
.PP
Definition at line 236 of file tlm_initiator_port.h.
.PP
References tlm_initiator_port_base::get_initiator_port_list(), tlm_initiator_port_base::get_reversed_initiator_port_list(), and tlm_initiator_port_base::get_target_port_list().
.SS "template<typename IF, int N> void \fBtlm_initiator_port\fP< IF, N >::bind (\fBtarget_port_type\fP & target_port_)\fC [inline]\fP"
.PP
bind(sc_export) overridden with port registration 
.PP
Definition at line 283 of file tlm_initiator_port.h.
.PP
References tlm_initiator_port< IF, N >::is_interface_bound_twice(), and tlm_initiator_port_base::register_target_port().
.PP
Referenced by tlm_initiator_port< IF, N >::operator()().
.SS "template<typename IF, int N> template<typename OTHER_IF> void \fBtlm_initiator_port\fP< IF, N >::bind (\fBtlm_target_port\fP< OTHER_IF > & target_port_)\fC [inline]\fP"
.PP
Case of the other port uses another interface as template: works only if OTHER_IF derives from IF. 
.PP
Definition at line 296 of file tlm_initiator_port.h.
.PP
References tlm_initiator_port< IF, N >::is_interface_bound_twice().
.SS "template<typename IF, int N> void \fBtlm_initiator_port\fP< IF, N >::operator() (\fBtarget_port_type\fP & target_port_)\fC [inline]\fP"
.PP
operator() (sc_export) overridden with port registration 
.PP
Definition at line 323 of file tlm_initiator_port.h.
.PP
References tlm_initiator_port< IF, N >::bind().
.SS "template<typename IF, int N = 1> template<typename OTHER_IF> void \fBtlm_initiator_port\fP< IF, N >::operator() (\fBtlm_target_port\fP< OTHER_IF > & target_port_)\fC [inline]\fP"
.PP
Case of the other port uses another interface as template: works only if OTHER_IF derives from IF. 
.PP
Definition at line 118 of file tlm_initiator_port.h.
.SS "template<typename IF, int N> void \fBtlm_initiator_port\fP< IF, N >::bind (sc_port_b< \fBinterface_type\fP > & port_)\fC [inline]\fP"
.PP
bind(sc_port) overridden with port registration 
.PP
Definition at line 332 of file tlm_initiator_port.h.
.PP
References tlm_initiator_port_base::get_reversed_initiator_port_list(), tlm_initiator_port_base::register_initiator_port(), and tlm_initiator_port_base::reversed_register_initiator_port().
.SS "template<typename IF, int N> void \fBtlm_initiator_port\fP< IF, N >::operator() (sc_port_b< \fBinterface_type\fP > & port_)\fC [inline]\fP"
.PP
operator() (sc_port) overridden with port registration 
.PP
Definition at line 352 of file tlm_initiator_port.h.
.PP
References tlm_initiator_port< IF, N >::bind().
.SS "template<typename IF, int N> void \fBtlm_initiator_port\fP< IF, N >::bind (\fBinterface_type\fP & interface_)\fC [inline]\fP"
.PP
bind(interface_type) overridden with port registration 
.PP
Definition at line 366 of file tlm_initiator_port.h.
.SS "template<typename IF, int N> void \fBtlm_initiator_port\fP< IF, N >::operator() (\fBinterface_type\fP & interface_)\fC [inline]\fP"
.PP
operator () (interface_type) overridden with port registration 
.PP
Definition at line 376 of file tlm_initiator_port.h.
.SS "template<typename IF, int N> bool \fBtlm_initiator_port\fP< IF, N >::is_interface_bound_twice (sc_export_base & target_port_)\fC [inline, protected]\fP"
.PP
Returns true and issues an error message and return true if the same interface is bound two times throught 2 differents target port.
.PP
Returns true and issues an error message if the same interface is bound two times throught 2 differents target port. 
.PP
Definition at line 167 of file tlm_initiator_port.h.
.PP
Referenced by tlm_initiator_port< IF, N >::bind().

.SH "Author"
.PP 
Generated automatically by Doxygen for TLM 2 from the source code.
