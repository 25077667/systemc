Index: sc_cthread_process.cpp
===================================================================
RCS file: /Users/acg/CVSROOT/systemc-2.3/src/sysc/kernel/sc_cthread_process.cpp,v
retrieving revision 1.5
diff -r1.5 sc_cthread_process.cpp
185,204d184
< //------------------------------------------------------------------------------
< //"sc_cthread_process::throw_reset"
< //
< // This virtual method is invoked when an reset is to be thrown. It sets the
< // wait count to zero. If the reset is asynchronous the process is scheduled
< // for an immediate reset throw.
< //------------------------------------------------------------------------------
< void sc_cthread_process::throw_reset( bool async )
< {     
< 	if ( m_state == ps_zombie ) return; // if process is dead don't bother.
< 
< 	m_throw_type = THROW_RESET;
< 	m_wait_cycle_n = 0;
< 	if ( async  && next_runnable() == 0 ) 
< 	{
< 	    simcontext()->push_runnable_thread( this ); 
< 	}
< }
< 
< 
Index: sc_cthread_process.h
===================================================================
RCS file: /Users/acg/CVSROOT/systemc-2.3/src/sysc/kernel/sc_cthread_process.h,v
retrieving revision 1.3
diff -r1.3 sc_cthread_process.h
107c107
<     virtual void throw_reset( bool async );
---
>     // @@@@#### REMOVE virtual void throw_reset( bool async );
Index: sc_event.cpp
===================================================================
RCS file: /Users/acg/CVSROOT/systemc-2.3/src/sysc/kernel/sc_event.cpp,v
retrieving revision 1.5
diff -r1.5 sc_event.cpp
220,227d219
< // |
< // | Notes:
< // |   (1) For processes that are dynamically waiting on this event we must
< // |       that if they are disabled they stay on the appropriate dynamic
< // |       queue. Disabled events are handled in this manner because this
< // |       event may be part of an and event list and its easier to keep the
< // |       processes on the event queue than it is to try to restore things
< // |       when the process is re-enabled.
232,233c224,226
<     int last_i; // index of last element in vector now accessing.
<     int size;   // size of vector now accessing.
---
>     int       last_i; // index of last element in vector now accessing.
>     int       size;   // size of vector now accessing.
> 
256c249
< 	for ( int i = 0; i <= last_i; )
---
> 	for ( int i = 0; i <= last_i; i++ )
259c252
< 	    if ( method_h->trigger_dynamic( this ) )
---
> 	    switch ( method_h->trigger_dynamic( this ) )
261c254,256
< 		m_simc->push_runnable_method( method_h );
---
> 	      case dt_rearm:
> 	        break;
> 	      case dt_remove:
264,270c259,265
< 	    }
< 	    else if ( method_h->current_state() == sc_process_b::ps_disabled )
< 	    {
< 		i++; // see note 1 above.
< 	    }
< 	    else
< 	    {
---
> 		i--;
> 		break;
> 	      case dt_run:
> 		m_simc->push_runnable_method( method_h );
> 		break;
> 	      case dt_run_remove:
> 		m_simc->push_runnable_method( method_h );
272a268,269
> 		i--;
>                 break;
299c296
< 	for ( int i = 0; i <= last_i; )
---
> 	for ( int i = 0; i <= last_i; i++ )
302c299
< 	    if ( thread_h->trigger_dynamic( this ) )
---
> 	    switch ( thread_h->trigger_dynamic( this ) )
304c301,303
< 		m_simc->push_runnable_thread( thread_h );
---
> 	      case dt_rearm:
> 	        break;
> 	      case dt_remove:
305a305
> 		i--;
307,313c307,312
< 	    }
< 	    else if ( thread_h->current_state() == sc_process_b::ps_disabled )
< 	    {
< 		i++; // see note 1 above.
< 	    }
< 	    else
< 	    {
---
> 		break;
> 	      case dt_run:
> 		m_simc->push_runnable_thread( thread_h );
> 		break;
> 	      case dt_run_remove:
> 		m_simc->push_runnable_thread( thread_h );
314a314
> 		i--;
315a316
>                 break;
Index: sc_event.h
===================================================================
RCS file: /Users/acg/CVSROOT/systemc-2.3/src/sysc/kernel/sc_event.h,v
retrieving revision 1.5
diff -r1.5 sc_event.h
349a350,359
>     enum dt_status {   // status from process' trigger_dynamic() method:
> 	dt_rearm = 0,  // dont run the process and dont remove it from 
> 	               // the event's queue.
> 	dt_remove,     // remove this process from the event's queue, and
> 	               // do not schedule it.
>         dt_run,        // the process should be scheduled for execution but the
>                        // the proces should stay on the event's queue.
>         dt_run_remove  // the process should be scheduled for execution and the
>                        // process should be removed from the event's queue.
>     };
Index: sc_method_process.cpp
===================================================================
RCS file: /Users/acg/CVSROOT/systemc-2.3/src/sysc/kernel/sc_method_process.cpp,v
retrieving revision 1.8
diff -r1.8 sc_method_process.cpp
178,181d177
<       case ps_suspended:
<       case ps_suspended_ready_to_run:
<         m_state = ps_disabled_suspended;
<         break;
182a179
>         m_state = m_state | ps_bit_disabled;
218c215
<     // RESUME OBJECT INSTANCE:
---
>     // RESUME THIS OBJECT INSTANCE:
220,230c217
<     switch( m_state )
<     {
<       case ps_disabled:
<         m_state = ps_normal;
<         break;
<       case ps_disabled_suspended:
<         m_state = ps_suspended;
<         break;
<       default:
<         break;
<     }
---
>     m_state = m_state & ~ps_bit_disabled;
265c252
<     m_throw_type = THROW_KILL;
---
>     m_throw_status = THROW_KILL;
384,386d370
<       case ps_disabled:
<         m_state = ps_disabled_suspended;
<         break;
387a372
>         m_state = m_state | ps_bit_suspended;
431a417
> 	{
436a423
>             simcontext()->push_runnable_method(this);
438,440c425
<         break;
<       case ps_disabled_suspended:
<         m_state = ps_disabled;
---
> 	}
442a428
>         m_state = m_state & ~ps_suspended;
451,453c437,443
< // This virtual method is invoked to "throw" a reset. If the reset is 
< // asynchronous the method will cancel any dynamic waits and queue this 
< // object instance to be executed. If the reset is synchronous this is a no-op.
---
> // This virtual method is invoked to "throw" a reset. 
> // If the reset is synchronous this is a no-op.
> //
> // If the reset is asynchronous we:
> //   (a) cancel any dynamic waits 
> //   (b) schedule it to execute.
> //   (c) if it is the active process actually throw a reset exception.
468,469c458,464
<         if ( next_runnable() == 0 ) 
<             simcontext()->push_runnable_method( this );
---
> 	if ( next_runnable() == 0 )
> 	    simcontext()->push_runnable_method( this );
> 	if ( RCAST<sc_method_handle>(sc_get_current_process_b()) == this )
> 	{
> 	    m_throw_status = THROWING_NOW;
> 	    throw sc_unwind_exception( true );
> 	}
511a507,522
> //   dt_rearm      - don't execute the method and don't remove it from the
> //                   event's queue.
> //   dt_remove     - the thread should not be scheduled for execution and the
> //                   process should be removed from the event's method queue.
> //   dt_run        - the thread should be scheduled for execution but the
> //                   the proces should stay on the event's thread queue.
> //   dt_run_remove - the thread should be scheduled for execution and the
> //                   process should be removed from the event's thread queue.
> //
> // Notes:
> //   (1) This method is identical to sc_thread_process::trigger_dynamic(), 
> //       but they cannot be combined as sc_process_b::trigger_dynamic() 
> //       because the signatures things like sc_event::remove_dynamic()
> //       have different overloads for sc_method_process* and sc_thread_process*.
> //       So if you change code here you'll also need to change it in 
> //       sc_thread_process.cpp.
513,514c524
< bool
< sc_method_process::trigger_dynamic( sc_event* e )
---
> sc_event::dt_status sc_method_process::trigger_dynamic( sc_event* e )
516,521c526,529
<     if( is_runnable() ) {
<         return false;
<     }
<     if ( m_state == ps_disabled ) {
<         return false;
<     }
---
>     sc_event::dt_status rc; // return code.
> 
>     // No time outs yet, and keep gcc happy.
> 
523c531,543
<     switch( m_trigger_type ) {
---
>     rc = sc_event::dt_remove;
> 
>     // If this thread is already runnable can't trigger an event.
> 
>     if( is_runnable() ) 
>     {
>         return sc_event::dt_remove;
>     }
> 
>     // Process based on the event type and current process state:
> 
>     switch( m_trigger_type ) 
>     {
525,533c545,565
<         m_event_p = 0;
<         m_trigger_type = STATIC;
<         return true;
<       case OR_LIST: 
<         m_event_list_p->remove_dynamic( this, e );
<         m_event_list_p->auto_delete();
<         m_event_list_p = 0;
<         m_trigger_type = STATIC;
<         return true;
---
>         if ( m_state == ps_normal )
> 	{
> 	    rc = sc_event::dt_run_remove;
> 	}
> 	else if ( m_state & ps_bit_disabled )
> 	{
>             return sc_event::dt_rearm;
> 	}
> 	else if ( m_state & ps_bit_suspended )
> 	{
> 	    m_state = m_state | ps_bit_ready_to_run;
>             rc = sc_event::dt_remove;
> 	}
> 	else
> 	{
> 	    rc = sc_event::dt_remove;
> 	}
> 	m_event_p = 0;
> 	m_trigger_type = STATIC;
> 	break;
> 
535,556c567,696
<         if( -- m_event_count == 0 ) {
<             // no need to remove_dynamic
<             m_event_list_p->auto_delete();
<             m_event_list_p = 0;
<             m_trigger_type = STATIC;
<             return true;
<         }
<         return false;
<       case TIMEOUT:
<         m_trigger_type = STATIC;
<         return true;
<       case EVENT_TIMEOUT:
<         if( e == m_event_p ) {
<             m_timeout_event_p->cancel();
<             m_timeout_event_p->reset();
<         } else {
<             m_timed_out = true;
<             m_event_p->remove_dynamic( this );
<         }
<         m_event_p = 0;
<         m_trigger_type = STATIC;
<         return true;
---
> 	if ( m_state & ps_bit_disabled )
> 	{
>             return sc_event::dt_rearm;
> 	}
>         -- m_event_count;
> 
>         if ( m_state == ps_normal )
> 	{
> 	    rc = m_event_count ? sc_event::dt_remove : sc_event::dt_run_remove;
> 	}
> 	else if ( m_state & ps_bit_suspended )
> 	{
> 	    if ( !m_event_count )
> 		m_state = m_state | ps_bit_ready_to_run;
>             rc = sc_event::dt_remove;
> 	}
> 	else
> 	{
> 	    rc = sc_event::dt_remove;
> 	}
> 	if ( m_event_count == 0 )
> 	{
> 	    m_event_list_p->auto_delete();
> 	    m_event_list_p = 0;
> 	    m_trigger_type = STATIC;
> 	}
> 	break;
> 
>       case OR_LIST:
>         if ( m_state == ps_normal )
> 	{
> 	    rc = sc_event::dt_run_remove;
> 	}
> 
> 	else if ( m_state & ps_bit_disabled )
> 	{
>             return sc_event::dt_rearm;
> 	}
> 
> 	else if ( m_state & ps_bit_suspended )
> 	{
> 	    m_state = m_state | ps_bit_ready_to_run;
>             rc = sc_event::dt_remove;
> 	}
> 
> 	else
> 	{
> 	    rc = sc_event::dt_remove;
> 	}
> 
> 	m_event_list_p->remove_dynamic( this, e );
> 	m_event_list_p->auto_delete();
> 	m_event_list_p = 0;
> 	m_trigger_type = STATIC;
> 	break;
> 
>       case TIMEOUT: 
>         if ( m_state == ps_normal )
> 	    rc = sc_event::dt_run_remove;
> 
> 	else if ( m_state & ps_bit_disabled )
>             return sc_event::dt_rearm; // @@@@####
> 
> 	else if ( m_state & ps_bit_suspended )
> 	{
>             m_state = ps_suspended_ready_to_run;
>             rc = sc_event::dt_remove;
> 	}
> 
> 	else
>             rc = sc_event::dt_remove;
> 
> 	m_trigger_type = STATIC;
> 	break;
> 
>       case EVENT_TIMEOUT: 
>         if ( e == m_timeout_event_p )
> 	{
> 	    if ( m_state == ps_normal )
> 	    {
> 		rc = sc_event::dt_run_remove;
> 	    }
> 	    else if ( m_state & ps_bit_disabled )
> 	    {
> 	        rc = sc_event::dt_remove;
> 	    }
> 	    else if ( m_state & ps_bit_suspended )
> 	    {
> 	        m_state = m_state | ps_bit_ready_to_run;
> 		rc = sc_event::dt_remove;
> 	    }
> 	    else
> 	    {
> 	        rc = sc_event::dt_remove;
> 	    }
> 	    m_timed_out = true;
> 	    m_event_p->remove_dynamic( this );
> 	    m_event_p = 0;
> 	    m_trigger_type = STATIC;
> 	}
> 	else
> 	{
> 	    if ( m_state == ps_normal )
> 	    {
> 		rc = sc_event::dt_run_remove;
> 	    }
> 	    else if ( m_state & ps_bit_disabled )
> 	    {
> 		if ( e == m_event_p ) 
> 		    return sc_event::dt_rearm;
> 		else
> 		    rc = sc_event::dt_remove;
> 	    }
> 	    else if ( m_state & ps_bit_suspended )
> 	    {
> 		m_state = ps_suspended_ready_to_run;
> 		rc = sc_event::dt_remove;
> 	    }
> 	    else
> 	    {
> 		rc = sc_event::dt_remove;
> 	    }
> 
> 	    m_timeout_event_p->cancel();
> 	    m_timeout_event_p->reset();
> 	    m_event_p = 0;
> 	    m_trigger_type = STATIC;
> 	}
> 	break;
> 
558,570c698,716
<         if( e != m_timeout_event_p ) {
<             m_timeout_event_p->cancel();
<             m_timeout_event_p->reset();
<         } else {
<             m_timed_out = true;
<         }
<         m_event_list_p->remove_dynamic( this, e );
<         m_event_list_p->auto_delete();
<         m_event_list_p = 0;
<         m_trigger_type = STATIC;
<         return true;
<       case AND_LIST_TIMEOUT:
<         if( e == m_timeout_event_p ) {
---
>         if ( e == m_timeout_event_p )
> 	{
> 	    if ( m_state == ps_normal )
> 	    {
> 		rc = sc_event::dt_run_remove;
> 	    }
> 	    else if ( m_state & ps_bit_disabled )
> 	    {
> 	        rc = sc_event::dt_remove;
> 	    }
> 	    else if ( m_state & ps_bit_suspended )
> 	    {
> 	        m_state = m_state | ps_bit_ready_to_run;
> 		rc = sc_event::dt_remove;
> 	    }
> 	    else
> 	    {
> 	        rc = sc_event::dt_remove;
> 	    }
572c718
<             m_event_list_p->remove_dynamic( this, e );
---
>             m_event_list_p->remove_dynamic( this, e ); 
574c720
<             m_event_list_p = 0;
---
>             m_event_list_p = 0; 
576,577c722,745
<             return true;
<         } else if( -- m_event_count == 0 ) {
---
> 	}
> 
> 	else
> 	{
> 	    if ( m_state == ps_normal )
> 	    {
> 		rc = sc_event::dt_run_remove;
> 	    }
> 
> 	    else if ( m_state & ps_bit_disabled )
> 	    {
> 		return sc_event::dt_rearm;
> 	    }
> 
> 	    else if ( m_state & ps_bit_suspended )
> 	    {
> 		m_state = m_state | ps_bit_ready_to_run;
> 		rc = sc_event::dt_remove;
> 	    }
> 
> 	    else
> 	    {
> 		rc = sc_event::dt_remove;
> 	    }
580c748,776
<             // no need to remove_dynamic
---
> 	    m_event_list_p->remove_dynamic( this, e ); 
> 	    m_event_list_p->auto_delete();
> 	    m_event_list_p = 0; 
> 	    m_trigger_type = STATIC;
> 	}
> 	break;
>       
>       case AND_LIST_TIMEOUT:
>         if ( e == m_timeout_event_p )
> 	{
> 	    if ( m_state == ps_normal )
> 	    {
> 		rc = sc_event::dt_run_remove;
> 	    }
> 	    else if ( m_state & ps_bit_disabled )
> 	    {
> 	        rc = sc_event::dt_remove;
> 	    }
> 	    else if ( m_state & ps_bit_suspended )
> 	    {
> 	        m_state = m_state | ps_bit_ready_to_run;
> 		rc = sc_event::dt_remove;
> 	    }
> 	    else
> 	    {
> 	        rc = sc_event::dt_remove;
> 	    }
>             m_timed_out = true;
>             m_event_list_p->remove_dynamic( this, e ); 
582c778
<             m_event_list_p = 0;
---
>             m_event_list_p = 0; 
584,587c780,817
<             return true;
<         }
<         return false;
<       case STATIC:
---
> 	}
> 
> 	else
> 	{
> 	    if ( m_state & ps_bit_disabled )
> 	    {
> 		return sc_event::dt_rearm;
> 	    }
> 	    -- m_event_count;
> 
> 	    if ( m_state == ps_normal )
> 	    {
> 		rc = m_event_count ? sc_event::dt_remove : 
> 		                     sc_event::dt_run_remove;
> 	    }
> 	    else if ( m_state & ps_bit_suspended )
> 	    {
> 		if ( m_event_count == 0 )
> 		    m_state = m_state | ps_bit_ready_to_run;
> 		rc = sc_event::dt_remove;
> 	    }
> 	    else
> 	    {
> 		rc = sc_event::dt_remove;
> 	    }
> 	    if ( m_event_count == 0 )
> 	    {
> 		m_timeout_event_p->cancel();
> 		m_timeout_event_p->reset();
> 		// no need to remove_dynamic
> 		m_event_list_p->auto_delete();
> 		m_event_list_p = 0; 
> 		m_trigger_type = STATIC;
> 	    }
> 	}
> 	break;
> 
>       case STATIC: {
589a820
>       }
591c822
<     return false;
---
>     return rc;
594d824
< 
Index: sc_method_process.h
===================================================================
RCS file: /Users/acg/CVSROOT/systemc-2.3/src/sysc/kernel/sc_method_process.h,v
retrieving revision 1.5
diff -r1.5 sc_method_process.h
174c174
<     bool trigger_dynamic( sc_event* );
---
>     sc_event::dt_status trigger_dynamic( sc_event* );
285,287c285,294
<       case ps_normal:    return true;
<       case ps_suspended: m_state = ps_suspended_ready_to_run; break;
<       default: break;
---
>       case ps_normal:    
>         return true;
>       case ps_suspended: 
>         m_state = ps_suspended_ready_to_run; 
> 	break;
>       case ps_disable_pending:
>         m_state = ps_disabled;
> 	return true;
>       default: 
>         break;
Index: sc_process.cpp
===================================================================
RCS file: /Users/acg/CVSROOT/systemc-2.3/src/sysc/kernel/sc_process.cpp,v
retrieving revision 1.8
diff -r1.8 sc_process.cpp
94a95
> #include "sysc/kernel/sc_event.h"
164c165
<     if ( m_state == ps_zombie ) return;    
---
>     if ( m_state & ps_bit_zombie ) return;    
278a280
>     m_trigger_type = STATIC;
299a302,305
> 	if ( method_h->m_timeout_event_p ) {
> 	    method_h->m_timeout_event_p->remove_dynamic(method_h);
> 	    method_h->m_timeout_event_p->cancel();
> 	}
384c390
<     m_throw_type( THROW_NONE ),
---
>     m_throw_status( THROW_NONE ),
Index: sc_process.h
===================================================================
RCS file: /Users/acg/CVSROOT/systemc-2.3/src/sysc/kernel/sc_process.h,v
retrieving revision 1.7
diff -r1.7 sc_process.h
453c453,455
<         THROW_RESET
---
>         THROW_ASYNC_RESET,
>         THROW_SYNC_RESET,
> 	THROWING_NOW
457,463c459,474
<         ps_disabled = 0,           // process is disabled.
<         ps_disable_pending,        // process to be disabled, but execute once.
<         ps_disabled_suspended,     // process is disabled and suspended.
<         ps_normal,                 // process is in normal execution.
<         ps_suspended,              // process is suspended.
<         ps_suspended_ready_to_run, // process is suspended, run it on resume.
<         ps_zombie                  // process has been killed.
---
> 	ps_bit_disabled = 1,      // process is disabled.
> 	ps_bit_pending  = 2,      // process id pending disabled.
> 	ps_bit_ready_to_run = 4,  // process is ready to run.
>         ps_bit_suspended = 8,     // process is suspended.
> 	ps_bit_zombie = 0x10,     // process is a zombie.
> 
>         ps_disabled = ps_bit_disabled,
>         ps_disable_pending = (ps_bit_disabled|ps_bit_pending),
>         ps_disabled_ready_to_run = (ps_bit_disabled|ps_bit_ready_to_run),
> 	ps_disabled_suspended = (ps_bit_disabled|ps_bit_suspended),
>         ps_disabled_suspended_rtr = (ps_bit_disabled|ps_bit_suspended|
> 	                             ps_bit_ready_to_run),
>         ps_normal = 0,
>         ps_suspended = ps_bit_suspended,
>         ps_suspended_ready_to_run = (ps_bit_suspended|ps_bit_ready_to_run),
>         ps_zombie = ps_bit_zombie 
464a476
> 
469a482
> 
489c502
<     inline process_state current_state() { return m_state; }
---
>     inline int current_state() { return m_state; }
581c594
<     process_state                m_state;           // Process state.
---
>     int                          m_state;           // Process state.
586c599
<     process_throw_type           m_throw_type;      // Throw type.
---
>     process_throw_type           m_throw_status;    // Exception throwing status
668c681,691
<     return m_throw_type == THROW_RESET || m_throw_type == THROW_KILL;
---
>     switch( m_throw_status )
>     {
>       case THROW_KILL:
>       case THROW_ASYNC_RESET:
>       case THROW_SYNC_RESET:
>       case THROWING_NOW:
>       case THROW_USER:
>         return true;
>       default:
>         return false;
>     }
729c752,754
< // or clear one.
---
> // or clear one. Note that this method may be called when there is no
> // active process, but rather the main simulator is executing so we must
> // check for that case.
736a762
> 
765,766c791,793
<     if ( m_throw_type == THROW_RESET && m_active_areset_n == 0 && 
<          m_active_reset_n == 0 )
---
>     if ( (m_throw_status == THROW_SYNC_RESET || 
>           m_throw_status == THROW_ASYNC_RESET) &&
>          m_active_areset_n == 0 && m_active_reset_n == 0 && !m_sticky_reset )
768c795
<         m_throw_type = THROW_NONE;
---
>         m_throw_status = THROW_NONE;
855,856c882,883
<     m_throw_type = ( m_active_areset_n || m_active_reset_n ) ?
<         THROW_RESET : THROW_NONE;
---
>     m_throw_status = m_active_areset_n ? THROW_ASYNC_RESET : 
>         ( m_active_reset_n  ?  THROW_SYNC_RESET : THROW_NONE);
872c899
<     return m_state == ps_zombie;
---
>     return m_state & ps_bit_zombie;
Index: sc_process_handle.h
===================================================================
RCS file: /Users/acg/CVSROOT/systemc-2.3/src/sysc/kernel/sc_process_handle.h,v
retrieving revision 1.10
diff -r1.10 sc_process_handle.h
528a529
> #if 0 // @@@@#### REMOVE
538a540,542
> #else
>     m_target_p->throw_user(helper, descendants);
> #endif
Index: sc_reset.cpp
===================================================================
RCS file: /Users/acg/CVSROOT/systemc-2.3/src/sysc/kernel/sc_reset.cpp,v
retrieving revision 1.7
diff -r1.7 sc_reset.cpp
144,145c144,145
<     int              process_i;    // index of process resetting.
<     int              process_n;    // # of processes to reset.
---
>     size_t           process_i;    // index of process resetting.
>     size_t           process_n;    // # of processes to reset.
180,183d179
< #if 0 // @@@@ REMOVE
<         if ( now_p->m_target_p->m_reset_p || now_p->m_target_p->m_areset_p )
<             SC_REPORT_ERROR(SC_ID_MULTIPLE_RESETS_,now_p->m_target_p->name());
< #endif
242,243c238
< void sc_reset::reset_signal_is(
<     bool async, const sc_in<bool>& port, bool level)
---
> void sc_reset::reset_signal_is( bool async, const sc_in<bool>& port, bool level)
282d276
<         // @@@@ CAN THIS GO? process_p->m_reset_level = level;
310d303
<         // @@@@ process_p->m_reset_level = level;
363d355
< 
Index: sc_runnable.h
===================================================================
RCS file: /Users/acg/CVSROOT/systemc-2.3/src/sysc/kernel/sc_runnable.h,v
retrieving revision 1.3
diff -r1.3 sc_runnable.h
80a81,82
>     inline void toggle_methods();
>     inline void toggle_threads();
Index: sc_runnable_int.h
===================================================================
RCS file: /Users/acg/CVSROOT/systemc-2.3/src/sysc/kernel/sc_runnable_int.h,v
retrieving revision 1.5
diff -r1.5 sc_runnable_int.h
147a148
> #if 0
149a151,156
> #else
>     return m_methods_push_head->next_runnable() == SC_NO_METHODS && 
>            m_methods_pop == SC_NO_METHODS &&
> 	   m_threads_push_head->next_runnable() == SC_NO_THREADS &&
> 	   m_threads_pop == SC_NO_THREADS;
> #endif
247c254
< // This is done by pushing it onto the front of the m_threads_pop_q.
---
> // This is done by pushing it onto the front of the m_threads_pop.
338,340c345,347
< // This method removes the supplied thread process from the push queue if it is
< // present. Note we clear the thread's next pointer so that it may be queued 
< // again.
---
> // This method removes the supplied thread process from the push or pop
> // queue if it is present. Note we clear the thread's next pointer so that it 
> // may be queued again.
347a355,356
>     // Search the push queue:
> 
350c359
< 	    now_p = now_p->next_runnable() )
---
> 	  now_p = now_p->next_runnable() )
359c368,386
<             break;
---
>             return;
>         }
>         prior_p = now_p;
>     }
> 
>     // Search the pop queue:
> 
>     prior_p = NULL;
>     for ( now_p = m_threads_pop; now_p != SC_NO_THREADS; 
> 	  now_p = now_p->next_runnable() )
>     {
>         if ( remove_p == now_p )
>         {
> 	    if ( prior_p )
> 		prior_p->set_next_runnable( now_p->next_runnable() );
> 	    else
> 	        m_threads_pop = now_p->next_runnable();
>             now_p->set_next_runnable(0);
>             return;
372c399
<     m_methods_pop = 0;
---
>     m_methods_pop = SC_NO_METHODS;
375c402
<     m_threads_pop = 0;
---
>     m_threads_pop = SC_NO_THREADS;
408a436,467
> //------------------------------------------------------------------------------
> //"sc_runnable::toggle_methods"
> //
> // This method moves the methods push queue to the pop queue and zeros the push
> // queue. This will only be done if the pop queue is presently empty.
> //------------------------------------------------------------------------------
> inline void sc_runnable::toggle_methods()
> {
>     if ( m_methods_pop == SC_NO_METHODS )
>     {
> 	m_methods_pop = m_methods_push_head->next_runnable();
> 	m_methods_push_head->set_next_runnable(SC_NO_METHODS);
> 	m_methods_push_tail = m_methods_push_head;
>     }
> }
> 
> //------------------------------------------------------------------------------
> //"sc_runnable::toggle_threads"
> //
> // This method moves the threads push queue to the pop queue and zeros the push
> // queue. This will only be done if the pop queue is presently empty.
> //------------------------------------------------------------------------------
> inline void sc_runnable::toggle_threads()
> {
>     if ( m_threads_pop == SC_NO_THREADS )
>     {
> 	m_threads_pop = m_threads_push_head->next_runnable();
> 	m_threads_push_head->set_next_runnable(SC_NO_THREADS);
> 	m_threads_push_tail = m_threads_push_head;
>     }
> }
> 
Index: sc_simcontext.cpp
===================================================================
RCS file: /Users/acg/CVSROOT/systemc-2.3/src/sysc/kernel/sc_simcontext.cpp,v
retrieving revision 1.8
diff -r1.8 sc_simcontext.cpp
550c550,551
<     while ( true ) {
---
>     while ( true ) 
>     {
556,557c557,558
< 	while( true ) {
< 
---
> 	while( true ) 
> 	{
560a562
> 	    m_runnable->toggle_methods();
570c572
< 		        if ( ex.is_reset() ) continue;
---
> 		        method_h->m_throw_status = sc_process_b::THROW_NONE;
582a585
> 	    m_runnable->toggle_threads();
600a604,605
> 	    // no more runnable processes
> 
602d606
< 		// no more runnable processes
605c609
< 	    m_runnable->toggle();
---
> 	    // @@@@#### m_runnable->toggle();
676c680
< 	m_runnable->toggle();
---
> 	// @@@@#### m_runnable->toggle();
959a964
> 	    if ( t > m_curr_time ) m_curr_time = t;
972a978
> 	    // if ( t > m_curr_time ) m_curr_time = t;
974d979
< 	if ( t > m_curr_time ) m_curr_time = t;
978d982
<     // if ( t > m_curr_time ) m_curr_time = t < until_t ? t : until_t;
1307c1311
< 	push_runnable_thread_front( thread_p );
---
> 	execute_thread_next( thread_p );
Index: sc_simcontext.h
===================================================================
RCS file: /Users/acg/CVSROOT/systemc-2.3/src/sysc/kernel/sc_simcontext.h,v
retrieving revision 1.8
diff -r1.8 sc_simcontext.h
375a376,380
>     sc_method_handle pop_runnable_method();
>     sc_thread_handle pop_runnable_thread();
> 
>     inline void preempt_with( sc_thread_handle );
> 
382,384d386
<     sc_method_handle pop_runnable_method();
<     sc_thread_handle pop_runnable_thread();
< 
Index: sc_simcontext_int.h
===================================================================
RCS file: /Users/acg/CVSROOT/systemc-2.3/src/sysc/kernel/sc_simcontext_int.h,v
retrieving revision 1.3
diff -r1.3 sc_simcontext_int.h
105a106,176
> // +----------------------------------------------------------------------------
> // |"sc_simcontext::preempt_with"
> // | 
> // | This method executes the supplied thread immediately, suspending the
> // | caller. After executing the supplied thread the caller's execution will
> // | be restored. It is used to allow a thread to immediately throw an 
> // | exception, e.g., when the thread's kill_process() method was called.
> // | There are three cases to consider:
> // |   (1) The caller is a method, e.g., murder by method.
> // |   (2) The caller is another thread instance, e.g., murder by thread.
> // |   (3) The caller is this thread instance, e.g., suicide.
> // |
> // | Arguments:
> // |     thread_h -> thread to be executed.
> // +----------------------------------------------------------------------------
> inline
> void
> sc_simcontext::preempt_with( sc_thread_handle thread_h )
> {
>     sc_thread_handle active_p; // active thread or null.
> 
>     // Determine the active process and take the thread to be run off the
>     // run queue, if its there, since we will be explicitly causing its 
>     // execution.
> 
>     active_p = DCAST<sc_thread_handle>(sc_get_current_process_b());
>     if ( thread_h->next_runnable() != NULL )
> 	remove_runnable_thread( thread_h );
> 
>     // THE CALLER IS A METHOD:
>     //
>     //   (a) Set the current process information to our thread.
>     //   (b) Invoke our thread directly by passing the run queue.
>     //   (c) Reset the current process information.
> 
>     if ( active_p == NULL )
>     {
> 	set_curr_proc( (sc_process_b*)thread_h );
> 	m_cor_pkg->yield( thread_h->m_cor_p );
> 	reset_curr_proc();
>     }
> 
>     // CALLER IS A THREAD, BUT NOT THE THREAD TO BE RUN:
>     //
>     //   (a) Push the calling thread onto the front of the runnable queue
>     //       so it be the first thread to be run after this thread.
>     //   (b) Push the thread to be run onto the front of the runnable queue so 
>     //       it will execute when we suspend the calling thread.
>     //   (c) Suspend the active thread.
> 
>     else if ( active_p != thread_h )
>     {
>         execute_thread_next( active_p );
> 	execute_thread_next( thread_h );
> 	active_p->suspend_me();
>     }
> 
>     // CALLER IS THE THREAD TO BE RUN:
>     //
>     //   (a) Push the thread to be run onto the front of the runnable queue so 
>     //       it will execute when we suspend the calling thread.
>     //   (b) Suspend the active thread.
> 
>     else
>     {
> 	execute_thread_next( thread_h );
> 	active_p->suspend_me();
>     }
> }
> 
> 
175,176d245
< 
< 
Index: sc_spawn.h
===================================================================
RCS file: /Users/acg/CVSROOT/systemc-2.3/src/sysc/kernel/sc_spawn.h,v
retrieving revision 1.3
diff -r1.3 sc_spawn.h
144,150c144,150
< 	sc_simcontext*      context_p;
< 	sc_spawn_object<T>* spawn_p;
< 	
< 	context_p = sc_get_curr_simcontext();
< 	spawn_p = new sc_spawn_object<T>(object);
< 	if ( !opt_p || !opt_p->is_method() )
< 	{
---
>     sc_simcontext*      context_p;
>     sc_spawn_object<T>* spawn_p;
>     
>     context_p = sc_get_curr_simcontext();
>     spawn_p = new sc_spawn_object<T>(object);
>     if ( !opt_p || !opt_p->is_method() )
>     {
152,156c152,156
< 		    name_p, true,
< 		    SC_MAKE_FUNC_PTR(sc_spawn_object<T>,semantics), 
< 		    spawn_p, opt_p 
< 	    );
< 	    return thread_handle;
---
>             name_p, true,
>             SC_MAKE_FUNC_PTR(sc_spawn_object<T>,semantics), 
>             spawn_p, opt_p 
>         );
>         return thread_handle;
158,159c158,159
< 	else
< 	{
---
>     else
>     {
161,165c161,165
< 		    name_p, true,
< 		    SC_MAKE_FUNC_PTR(sc_spawn_object<T>,semantics), 
< 		    spawn_p, opt_p 
< 	    );
< 	    return method_handle;
---
>             name_p, true,
>             SC_MAKE_FUNC_PTR(sc_spawn_object<T>,semantics), 
>             spawn_p, opt_p 
>         );
>         return method_handle;
246,253c246,253
< 	sc_simcontext*      context_p;
< 	sc_spawn_object_v<T>* spawn_p;
< 	
< 	context_p = sc_get_curr_simcontext();
< 	
< 	spawn_p = new sc_spawn_object_v<T>(r_p, object);
< 	if ( !opt_p || !opt_p->is_method() )
< 	{
---
>     sc_simcontext*      context_p;
>     sc_spawn_object_v<T>* spawn_p;
>     
>     context_p = sc_get_curr_simcontext();
>     
>     spawn_p = new sc_spawn_object_v<T>(r_p, object);
>     if ( !opt_p || !opt_p->is_method() )
>     {
255,262c255,262
< 		    name_p, true,
< 		    SC_MAKE_FUNC_PTR(sc_spawn_object_v<T>,semantics), 
< 		    spawn_p, opt_p 
< 	    );
< 	    return thread_handle;
< 	}
< 	else
< 	{
---
>             name_p, true,
>             SC_MAKE_FUNC_PTR(sc_spawn_object_v<T>,semantics), 
>             spawn_p, opt_p 
>         );
>         return thread_handle;
>     }
>     else
>     {
264,268c264,268
< 		    name_p, true,
< 		    SC_MAKE_FUNC_PTR(sc_spawn_object_v<T>,semantics), 
< 		    spawn_p, opt_p 
< 	    );
< 	    return method_handle;
---
>             name_p, true,
>             SC_MAKE_FUNC_PTR(sc_spawn_object_v<T>,semantics), 
>             spawn_p, opt_p 
>         );
>         return method_handle;
299,306c299,306
< 	sc_simcontext*      context_p;
< 	sc_spawn_object_v<T,R>* spawn_p;
< 	
< 	context_p = sc_get_curr_simcontext();
< 	
< 	spawn_p = new sc_spawn_object_v<T,R>(r_p, object);
< 	if ( !opt_p || !opt_p->is_method() )
< 	{
---
>     sc_simcontext*      context_p;
>     sc_spawn_object_v<T,R>* spawn_p;
>     
>     context_p = sc_get_curr_simcontext();
>     
>     spawn_p = new sc_spawn_object_v<T,R>(r_p, object);
>     if ( !opt_p || !opt_p->is_method() )
>     {
308,313c308,313
< 		    name_p, true,
< 			static_cast<sc_core::SC_ENTRY_FUNC>(
< 			    &sc_spawn_object_v<T,R>::semantics),
< 		    spawn_p, opt_p 
< 	    );
< 	    return thread_handle;
---
>             name_p, true,
>             static_cast<sc_core::SC_ENTRY_FUNC>(
>                 &sc_spawn_object_v<T,R>::semantics),
>             spawn_p, opt_p 
>         );
>         return thread_handle;
315,316c315,316
< 	else
< 	{
---
>     else
>     {
318,323c318,323
< 		    name_p, true,
< 			static_cast<sc_core::SC_ENTRY_FUNC>(
< 		        &sc_spawn_object_v<T,R>::semantics), 
< 		    spawn_p, opt_p 
< 	    );
< 	    return method_handle;
---
>             name_p, true,
>             static_cast<sc_core::SC_ENTRY_FUNC>(
>                 &sc_spawn_object_v<T,R>::semantics), 
>             spawn_p, opt_p 
>         );
>         return method_handle;
Index: sc_thread_process.cpp
===================================================================
RCS file: /Users/acg/CVSROOT/systemc-2.3/src/sysc/kernel/sc_thread_process.cpp,v
retrieving revision 1.12
diff -r1.12 sc_thread_process.cpp
165,166d164
< 
< 	// simc_p->cor_pkg()->abort( simc_p->next_cor() );
207,210d204
<       case ps_suspended:
<       case ps_suspended_ready_to_run:
<         m_state = ps_disabled_suspended;
<         break;
211a206
>         m_state = m_state | ps_bit_disabled;
254,256c249,253
<       case ps_disabled_suspended:
<         m_state = ps_suspended;
<         break;
---
>       case ps_disabled_ready_to_run:
>         m_state = ps_normal;
> 	if ( next_runnable() == 0 )
> 	    simcontext()->push_runnable_thread(this);
> 	break;
257a255
>         m_state = m_state & ~ps_bit_disabled; 
272c270
<     sc_thread_handle                 active_p;   // active process.
---
>     sc_thread_handle                 active_p;   // active thread process or 0.
296,304c294,298
<     // (1) If this is not a suicide we need to push the currently running
<     //     process onto the front of the run queue, then push this process
<     //     onto the front of the turn queue, and then suspend the currently
<     //     running process so that the kill gets done, and the currently
<     //     running process then resumes.
<     //
<     // (2) If this is a suicide we need to push this process onto the 
<     //     front of the run queue and suspend it so the kill gets thrown.
<  
---
>     // We have 3 cases to consider:
>     // (1) The murderer is a method, or the simulator proper.
>     // (2) The murderer is another thread.
>     // (3) This is a suicide.
> 
307c301
<         m_throw_type = THROW_KILL;
---
>         m_throw_status = THROW_KILL;
309c303,320
<         active_p = RCAST<sc_thread_handle>(sc_get_current_process_b());
---
> #if 1
>         context_p->preempt_with(this);
> #else
>         active_p = DCAST<sc_thread_handle>(sc_get_current_process_b());
> 
> 	// Murderer is a method, or the simulator proper: execute this
> 	// thread directly.
> 
> 	if ( active_p == NULL )
> 	{
> 	    context_p->run_now( this );
> 	}
> 
> 	// Murderer is another thread:
> 	//   (a) push the currently running process onto the front of the run 
> 	//       queue if it is a thread.
> 	//   (b) then push this thread onto the front of the run queue,
> 	//   (c) suspend the currently running thread.
311c322,323
<         if ( this != active_p && active_p )
---
> 	else if ( this != active_p )
> 	{
313,315c325,332
< 	if ( next_runnable() != 0 )
< 	    context_p->remove_runnable_thread(this);
< 	context_p->execute_thread_next(this);
---
> 	    if ( next_runnable() != 0 )
> 		context_p->remove_runnable_thread(this);
> 	    context_p->execute_thread_next(this);
> 	    suspend_me();
> 	}
> 
> 	// This is a suicide: push this thread on to the front of the run
> 	// queue and suspend it to we wake up in the throw code.
317,318d333
<         if ( this != active_p && active_p )
< 	    active_p->suspend_me();
319a335,338
> 	{
> 	    if ( next_runnable() != 0 )
> 		context_p->remove_runnable_thread(this);
> 	    context_p->execute_thread_next(this);
320a340,341
> 	}
> #endif
385c406
<         if ( next_runnable() == 0 ) 
---
>         if ( next_runnable() == 0 )  // @@@@#### does this need to be done elsewhere?
392a414
> 	    simcontext()->push_runnable_thread(this);
394,396c416
<         break;
<       case ps_disabled_suspended:
<         m_state = ps_disabled;
---
> 	remove_dynamic_events();  // order important.
398a419
>         m_state = m_state & ~ps_bit_suspended;
555,557d575
<       case ps_disabled:
<         m_state = ps_disabled_suspended;
<         break;
558a577
> 	m_state = m_state | ps_bit_suspended;
574c593
<     // IF THIS INSTANCE IS DEAD IGNORE THE REQUEST
---
>     // If the thread to be reset is dead ignore the call.
576c595
<     if ( m_state == ps_zombie ) return;
---
>     if ( m_state & ps_bit_zombie ) return;
579c598
<     // SET THE THROW TYPE AND CLEAR ANY PENDING DYNAMIC EVENTS:
---
>     // Set the throw type and clear any pending dynamic events: 
581c600
<     m_throw_type = THROW_RESET;
---
>     m_throw_status = async ? THROW_ASYNC_RESET : THROW_SYNC_RESET;
582a602
>     // @@@@#### should we really do a remove_events here?
584c604
<     // IF REQUESTED TO, IMMEDIATELY SCHEDULE THE RESET:
---
>     // If this is an asynchronous reset execute it immediately:
586,587c606
<     if ( async && (next_runnable() == 0) )
<             simcontext()->push_runnable_thread( this );
---
>     if ( async ) simcontext()->preempt_with( this );
589,602d607
<     // IF THE ACTIVE THREAD IS NOT THIS OBJECT INSTANCE:
<     //
<     // We will need so suspend it so that we can execute the reset on our
<     // object instance:
<     //    (1) Reschedule the active thread for later execution.
<     //    (2) Suspend the active thread so that this thread being reset can 
<     //        execute its reset if its sensitivity is activated.
< 
<     active_p = RCAST<sc_thread_handle>(sc_get_current_process_b());
<     if ( this != active_p && active_p )
<     {
< 	simcontext()->push_runnable_thread( active_p );
< 	active_p->suspend_me();
<     }
632c637
<     if ( m_state == ps_zombie ) return;
---
>     if ( m_state & ps_bit_zombie ) return;
634c639
<     m_throw_type = THROW_USER;
---
>     m_throw_status = THROW_USER;
636a642
> #if 0 // @@@@#### REMOVE
637a644,646
> #else
>     simcontext()->preempt_with( this );
> #endif
656a666,683
> // This method returns the status of this object instance with respect to 
> // the supplied event. There are 3 potential values to return:
> //   dt_rearm      - don't execute the thread and don't remove it from the
> //                   event's queue.
> //   dt_remove     - the thread should not be scheduled for execution and
> //                   the process should be moved from the event's thread queue.
> //   dt_run        - the thread should be scheduled for execution but the
> //                   the proces should stay on the event's thread queue.
> //   dt_run_remove - the thread should be scheduled for execution and the
> //                   process should be removed from the event's thread queue.
> //
> // Notes:
> //   (1) This method is identical to sc_method_process::trigger_dynamic(), 
> //       but they cannot be combined as sc_process_b::trigger_dynamic() 
> //       because the signatures things like sc_event::remove_dynamic()
> //       have different overloads for sc_thread_process* and sc_method_process*.
> //       So if you change code here you'll also need to change it in 
> //       sc_method_process.cpp.
658c685
< bool sc_thread_process::trigger_dynamic( sc_event* e )
---
> sc_event::dt_status sc_thread_process::trigger_dynamic( sc_event* e )
660,661c687
<     // If this process is already runnable, or it is disabled we can't trigger
<     // an event.
---
>     sc_event::dt_status rc; // return code.
663,666c689,696
<     if( is_runnable() ) {
<         return false;
<     }
<     if ( m_state == ps_disabled || m_state == ps_disable_pending )
---
>     // No time outs yet, and keep gcc happy.
> 
>     m_timed_out = false;
>     rc = sc_event::dt_remove;
> 
>     // If this thread is already runnable can't trigger an event.
> 
>     if( is_runnable() ) 
668c698
< 	return false;
---
>         return sc_event::dt_remove;
671c701
<     // Process based on the event type:
---
>     // Process based on the event type and current process state:
673,727c703,877
<     m_timed_out = false;
<     switch( m_trigger_type ) {
<     case EVENT: {
<         m_trigger_type = STATIC;
<         m_event_p = 0;
<         return true;
<     }
<     case OR_LIST: {
<         m_event_list_p->remove_dynamic( this, e );
<         m_event_list_p->auto_delete();
<         m_event_list_p = 0;
<         m_trigger_type = STATIC;
<         return true;
<     }
<     case AND_LIST: {
<         if( -- m_event_count == 0 ) {
<             // no need to remove_dynamic
<             m_event_list_p->auto_delete();
<             m_event_list_p = 0;
<             m_trigger_type = STATIC;
<             return true;
<         }
<         return false;
<     }
<     case TIMEOUT: {
<         m_trigger_type = STATIC;
<         return true;
<     }
<     case EVENT_TIMEOUT: {
<         if( e == m_event_p ) {
<             m_timeout_event_p->cancel();
<             m_timeout_event_p->reset();
<         } else {
<             m_timed_out = true;
<             m_event_p->remove_dynamic( this );
<         }
<         m_event_p = 0;
<         m_trigger_type = STATIC;
<         return true;
<     }
<     case OR_LIST_TIMEOUT: {
<         if( e != m_timeout_event_p ) {
<             m_timeout_event_p->cancel();
<             m_timeout_event_p->reset();
<         } else {
<             m_timed_out = true;
<         }
<         m_event_list_p->remove_dynamic( this, e );
<         m_event_list_p->auto_delete();
<         m_event_list_p = 0;
<         m_trigger_type = STATIC;
<         return true;
<     }
<     case AND_LIST_TIMEOUT: {
<         if( e == m_timeout_event_p ) {
---
>     switch( m_trigger_type ) 
>     {
>       case EVENT: 
>         if ( m_state == ps_normal )
> 	{
> 	    rc = sc_event::dt_run_remove;
> 	}
> 	else if ( m_state & ps_bit_disabled )
> 	{
>             return sc_event::dt_rearm;
> 	}
> 	else if ( m_state & ps_bit_suspended )
> 	{
> 	    m_state = m_state | ps_bit_ready_to_run;
>             rc = sc_event::dt_remove;
> 	}
> 	else
> 	{
> 	    rc = sc_event::dt_remove;
> 	}
> 	m_event_p = 0;
> 	m_trigger_type = STATIC;
> 	break;
> 
>       case AND_LIST:
> 	if ( m_state & ps_bit_disabled )
> 	{
>             return sc_event::dt_rearm;
> 	}
>         -- m_event_count;
> 
>         if ( m_state == ps_normal )
> 	{
> 	    rc = m_event_count ? sc_event::dt_remove : sc_event::dt_run_remove;
> 	}
> 	else if ( m_state & ps_bit_suspended )
> 	{
> 	    if ( m_event_count == 0 )
> 		m_state = m_state | ps_bit_ready_to_run;
>             rc = sc_event::dt_remove;
> 	}
> 	else
> 	{
> 	    rc = sc_event::dt_remove;
> 	}
> 	if ( m_event_count == 0 )
> 	{
> 	    m_event_list_p->auto_delete();
> 	    m_event_list_p = 0;
> 	    m_trigger_type = STATIC;
> 	}
> 	break;
> 
>       case OR_LIST:
>         if ( m_state == ps_normal )
> 	{
> 	    rc = sc_event::dt_run_remove;
> 	}
> 
> 	else if ( m_state & ps_bit_disabled )
> 	{
>             return sc_event::dt_rearm;
> 	}
> 
> 	else if ( m_state & ps_bit_suspended )
> 	{
> 	    m_state = m_state | ps_bit_ready_to_run;
>             rc = sc_event::dt_remove;
> 	}
> 
> 	else
> 	{
> 	    rc = sc_event::dt_remove;
> 	}
> 
> 	m_event_list_p->remove_dynamic( this, e );
> 	m_event_list_p->auto_delete();
> 	m_event_list_p = 0;
> 	m_trigger_type = STATIC;
> 	break;
> 
>       case TIMEOUT: 
>         if ( m_state == ps_normal )
> 	    rc = sc_event::dt_run_remove;
> 
> 	else if ( m_state & ps_bit_disabled )
>             return sc_event::dt_rearm; // @@@@####
> 
> 	else if ( m_state & ps_bit_suspended )
> 	{
>             m_state = ps_suspended_ready_to_run;
>             rc = sc_event::dt_remove;
> 	}
> 
> 	else
>             rc = sc_event::dt_remove;
> 
> 	m_trigger_type = STATIC;
> 	break;
> 
>       case EVENT_TIMEOUT: 
>         if ( e == m_timeout_event_p )
> 	{
> 	    if ( m_state == ps_normal )
> 	    {
> 		rc = sc_event::dt_run_remove;
> 	    }
> 	    else if ( m_state & ps_bit_disabled )
> 	    {
> 	        rc = sc_event::dt_remove;
> 	    }
> 	    else if ( m_state & ps_bit_suspended )
> 	    {
> 	        m_state = m_state | ps_bit_ready_to_run;
> 		rc = sc_event::dt_remove;
> 	    }
> 	    else
> 	    {
> 	        rc = sc_event::dt_remove;
> 	    }
> 	    m_timed_out = true;
> 	    m_event_p->remove_dynamic( this );
> 	    m_event_p = 0;
> 	    m_trigger_type = STATIC;
> 	}
> 	else
> 	{
> 	    if ( m_state == ps_normal )
> 	    {
> 		rc = sc_event::dt_run_remove;
> 	    }
> 	    else if ( m_state & ps_bit_disabled )
> 	    {
> 		if ( e == m_event_p ) 
> 		    return sc_event::dt_rearm;
> 		else
> 		    rc = sc_event::dt_remove;
> 	    }
> 	    else if ( m_state & ps_bit_suspended )
> 	    {
> 		m_state = ps_suspended_ready_to_run;
> 		rc = sc_event::dt_remove;
> 	    }
> 	    else
> 	    {
> 		rc = sc_event::dt_remove;
> 	    }
> 
> 	    m_timeout_event_p->cancel();
> 	    m_timeout_event_p->reset();
> 	    m_event_p = 0;
> 	    m_trigger_type = STATIC;
> 	}
> 	break;
> 
>       case OR_LIST_TIMEOUT:
>         if ( e == m_timeout_event_p )
> 	{
> 	    if ( m_state == ps_normal )
> 	    {
> 		rc = sc_event::dt_run_remove;
> 	    }
> 	    else if ( m_state & ps_bit_disabled )
> 	    {
> 	        rc = sc_event::dt_remove;
> 	    }
> 	    else if ( m_state & ps_bit_suspended )
> 	    {
> 	        m_state = m_state | ps_bit_ready_to_run;
> 		rc = sc_event::dt_remove;
> 	    }
> 	    else
> 	    {
> 	        rc = sc_event::dt_remove;
> 	    }
729c879
<             m_event_list_p->remove_dynamic( this, e );
---
>             m_event_list_p->remove_dynamic( this, e ); 
731c881
<             m_event_list_p = 0;
---
>             m_event_list_p = 0; 
733,734c883,906
<             return true;
<         } else if( -- m_event_count == 0 ) {
---
> 	}
> 
> 	else
> 	{
> 	    if ( m_state == ps_normal )
> 	    {
> 		rc = sc_event::dt_run_remove;
> 	    }
> 
> 	    else if ( m_state & ps_bit_disabled )
> 	    {
> 		return sc_event::dt_rearm;
> 	    }
> 
> 	    else if ( m_state & ps_bit_suspended )
> 	    {
> 		m_state = m_state | ps_bit_ready_to_run;
> 		rc = sc_event::dt_remove;
> 	    }
> 
> 	    else
> 	    {
> 		rc = sc_event::dt_remove;
> 	    }
737c909,937
<             // no need to remove_dynamic
---
> 	    m_event_list_p->remove_dynamic( this, e ); 
> 	    m_event_list_p->auto_delete();
> 	    m_event_list_p = 0; 
> 	    m_trigger_type = STATIC;
> 	}
> 	break;
>       
>       case AND_LIST_TIMEOUT:
>         if ( e == m_timeout_event_p )
> 	{
> 	    if ( m_state == ps_normal )
> 	    {
> 		rc = sc_event::dt_run_remove;
> 	    }
> 	    else if ( m_state & ps_bit_disabled )
> 	    {
> 	        rc = sc_event::dt_remove;
> 	    }
> 	    else if ( m_state & ps_bit_suspended )
> 	    {
> 	        m_state = m_state | ps_bit_ready_to_run;
> 		rc = sc_event::dt_remove;
> 	    }
> 	    else
> 	    {
> 	        rc = sc_event::dt_remove;
> 	    }
>             m_timed_out = true;
>             m_event_list_p->remove_dynamic( this, e ); 
739c939
<             m_event_list_p = 0;
---
>             m_event_list_p = 0; 
741,745c941,978
<             return true;
<         }
<         return false;
<     }
<     case STATIC: {
---
> 	}
> 
> 	else
> 	{
> 	    if ( m_state & ps_bit_disabled )
> 	    {
> 		return sc_event::dt_rearm;
> 	    }
> 	    -- m_event_count;
> 
> 	    if ( m_state == ps_normal )
> 	    {
> 		rc = m_event_count ? sc_event::dt_remove : 
> 		                     sc_event::dt_run_remove;
> 	    }
> 	    else if ( m_state & ps_bit_suspended )
> 	    {
> 		if ( m_event_count == 0 )
> 		    m_state = m_state | ps_bit_ready_to_run;
> 		rc = sc_event::dt_remove;
> 	    }
> 	    else
> 	    {
> 		rc = sc_event::dt_remove;
> 	    }
> 	    if ( m_event_count == 0 )
> 	    {
> 		m_timeout_event_p->cancel();
> 		m_timeout_event_p->reset();
> 		// no need to remove_dynamic
> 		m_event_list_p->auto_delete();
> 		m_event_list_p = 0; 
> 		m_trigger_type = STATIC;
> 	    }
> 	}
> 	break;
> 
>       case STATIC: {
747a981
>       }
749,750c983
<     }
<     return false;
---
>     return rc;
Index: sc_thread_process.h
===================================================================
RCS file: /Users/acg/CVSROOT/systemc-2.3/src/sysc/kernel/sc_thread_process.h,v
retrieving revision 1.10
diff -r1.10 sc_thread_process.h
188c188
<     bool trigger_dynamic( sc_event* );
---
>     sc_event::dt_status trigger_dynamic( sc_event* );
231c231
<     // IF WE ARE THROWING AN EXCEPTION DISPATCH THIS THREAD:
---
>     // SPECIAL CASE NORMAL STATE FOR DISPATCHING SPEED:
233c233
<     if ( m_throw_type != THROW_NONE ) 
---
>     if ( m_state == ps_normal )
235c235,241
<     	return true;
---
> 	if ( m_throw_status != THROW_NONE )  return true;
>         if ( m_wait_cycle_n > 0 )
>         {
>             --m_wait_cycle_n;
>             return false;
>         }
>         return true;
237a244,253
>     // WE ARE THROWING AN EXCEPTION THAT TRUMPS SUSPEND/DISABLE 
>     //
>     // Schedule the process so it can throw the exception.
> 
>     if ( m_throw_status == THROW_KILL ||
> 	 m_throw_status == THROW_ASYNC_RESET ||
> 	 m_throw_status == THROW_USER ) 
>     {
> 	 return true;
>     }
242a259
>       // No-op: its handled above.
244,249c261,265
<         if ( m_wait_cycle_n > 0 )
<         {
<             --m_wait_cycle_n;
<             return false;
<         }
<         return true;
---
>         return true; 
> 
>       // Down count the number of waits necessary to wake the process, if
>       // its ready to be awakened change its status.
> 
257a274,277
> 
>       // The process has been disabled, but its on the run queue, so let it
>       // run once and then disable it.
> 
259c279,280
<         if ( m_wait_cycle_n > 0 ) // this should never happen, but check anyway.
---
>         m_state = ps_disabled;
>         if ( m_wait_cycle_n > 0 )
264,265c285,297
<         m_state = ps_disabled;
< 	return true;  
---
> 	return true;
> 
>       // The process is disabled down count its waits (really?)
> 
> #if 0 // @@@@#####
>       case ps_disabled:
>         if ( m_wait_cycle_n > 0 )
>         {
>             --m_wait_cycle_n;
>         }
> 	break;
> #endif
> 
305c337
<     // IF WE ARE IN RESET BECAUSE OF A THROW, THROW THAT EXCEPTION:
---
>     // IF THERE IS A THROW TO BE DONE FOR THIS PROCESS DO IT NOW:
307,311c339
<     // (1) If the throw condition is gone this is a no-op.
<     // (2) If we have a reset throw reset the throw flag if a reset condition
<     //     no longer exists. If it does exist leave it set. Regardless we
<     //     throw an sc_user exception to service the reset that got us here.
<     // (3) If it is a user throw reset the throw flag and throw it.
---
>     // Optimize THROW_NONE for speed as it is the normal case.
313,317c341,343
<     if ( m_throw_type == THROW_NONE )
<     {
<         return;
<     }
<     else if ( m_throw_type == THROW_RESET )
---
>     if ( m_throw_status == THROW_NONE ) return;
> 
>     switch( m_throw_status )
318a345,346
>       case THROW_ASYNC_RESET:
>       case THROW_SYNC_RESET:
320,326c348,353
< 	m_throw_type = ( m_active_areset_n || m_active_reset_n ) ?
< 	    THROW_RESET : THROW_NONE;
<         throw sc_unwind_exception( true );
<     }
<     else if ( m_throw_type == THROW_USER )
<     {
<         m_throw_type = THROW_NONE; 
---
> 	m_throw_status = THROWING_NOW;
>         throw sc_unwind_exception( true ); 
> 	break;
> 
>       case THROW_USER:
> 	m_throw_status = THROWING_NOW;
328,331c355,358
<     }
<     else if ( m_throw_type == THROW_KILL )
<     {
<         // m_throw_type = THROW_NONE;  // @@@@####
---
> 	break;
> 
>       case  THROW_KILL:
> 	m_throw_status = THROWING_NOW;
332a360,363
> 	break;
> 
>       default: // THROWING_NOW
>         break;
