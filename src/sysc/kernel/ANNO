1.1          (acg      15-Dec-06): /*****************************************************************************
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):   The following code is derived, directly or indirectly, from the SystemC
1.21         (acg      13-Feb-11):   source code Copyright (c) 1996-2011 by all Contributors.
1.1          (acg      15-Dec-06):   All Rights reserved.
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):   The contents of this file are subject to the restrictions and limitations
1.26         (acg      18-Feb-11):   set forth in the SystemC Open Source License Version 3.0 (the "License");
1.1          (acg      15-Dec-06):   You may not use this file except in compliance with such restrictions and
1.1          (acg      15-Dec-06):   limitations. You may obtain instructions on how to receive a copy of the
1.1          (acg      15-Dec-06):   License at http://www.systemc.org/. Software distributed by Contributors
1.1          (acg      15-Dec-06):   under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF
1.1          (acg      15-Dec-06):   ANY KIND, either express or implied. See the License for the specific
1.1          (acg      15-Dec-06):   language governing rights and limitations under the License.
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):  *****************************************************************************/
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): /*****************************************************************************
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):   sc_thread_process.cpp -- Thread process implementation
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):   Original Author: Andy Goodrich, Forte Design Systems, 4 August 2005
1.1          (acg      15-Dec-06):                
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):  *****************************************************************************/
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): /*****************************************************************************
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):   MODIFICATION LOG - modifiers, enter your name, affiliation, date and
1.1          (acg      15-Dec-06):   changes you are making here.
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):       Name, Affiliation, Date:
1.1          (acg      15-Dec-06):   Description of Modification:
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):  *****************************************************************************/
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): // $Log: sc_thread_process.cpp,v $
1.44         (acg      11-Apr-11): // Revision 1.43  2011/04/10 22:12:32  acg
1.44         (acg      11-Apr-11): //  Andy Goodrich: adding debugging macros.
1.44         (acg      11-Apr-11): //
1.43         (acg      10-Apr-11): // Revision 1.42  2011/04/08 22:40:26  acg
1.43         (acg      10-Apr-11): //  Andy Goodrich: moved the reset event notification code out of throw_reset()
1.43         (acg      10-Apr-11): //  and into suspend_me.
1.43         (acg      10-Apr-11): //
1.42         (acg      08-Apr-11): // Revision 1.41  2011/04/08 18:24:07  acg
1.42         (acg      08-Apr-11): //  Andy Goodrich: fix asynchronous reset dispatch and when the reset_event()
1.42         (acg      08-Apr-11): //  is fired.
1.42         (acg      08-Apr-11): //
1.41         (acg      08-Apr-11): // Revision 1.40  2011/04/05 20:50:57  acg
1.41         (acg      08-Apr-11): //  Andy Goodrich:
1.41         (acg      08-Apr-11): //    (1) changes to make sure that event(), posedge() and negedge() only
1.41         (acg      08-Apr-11): //        return true if the clock has not moved.
1.41         (acg      08-Apr-11): //    (2) fixes for method self-resumes.
1.41         (acg      08-Apr-11): //    (3) added SC_PRERELEASE_VERSION
1.41         (acg      08-Apr-11): //    (4) removed kernel events from the object hierarchy, added
1.41         (acg      08-Apr-11): //        sc_hierarchy_name_exists().
1.41         (acg      08-Apr-11): //
1.40         (acg      05-Apr-11): // Revision 1.39  2011/04/01 22:30:39  acg
1.40         (acg      05-Apr-11): //  Andy Goodrich: change hard assertion to warning for trigger_dynamic()
1.40         (acg      05-Apr-11): //  getting called when there is only STATIC sensitivity. This can result
1.40         (acg      05-Apr-11): //  because of sc_process_handle::throw_it().
1.40         (acg      05-Apr-11): //
1.39         (acg      01-Apr-11): // Revision 1.38  2011/03/23 16:17:52  acg
1.39         (acg      01-Apr-11): //  Andy Goodrich: don't emit an error message for a resume on a disabled
1.39         (acg      01-Apr-11): //  process that is not suspended.
1.39         (acg      01-Apr-11): //
1.38         (acg      23-Mar-11): // Revision 1.37  2011/03/20 13:43:23  acg
1.38         (acg      23-Mar-11): //  Andy Goodrich: added async_signal_is() plus suspend() as a corner case.
1.38         (acg      23-Mar-11): //
1.37         (acg      20-Mar-11): // Revision 1.36  2011/03/08 20:49:31  acg
1.37         (acg      20-Mar-11): //  Andy Goodrich: implement coarse checking for synchronous reset - suspend
1.37         (acg      20-Mar-11): //  interaction.
1.37         (acg      20-Mar-11): //
1.36         (acg      08-Mar-11): // Revision 1.35  2011/03/08 20:32:28  acg
1.36         (acg      08-Mar-11): //  Andy Goodrich: implemented "coarse" checking for undefined process
1.36         (acg      08-Mar-11): //  control interactions.
1.36         (acg      08-Mar-11): //
1.35         (acg      08-Mar-11): // Revision 1.34  2011/03/07 18:25:19  acg
1.35         (acg      08-Mar-11): //  Andy Goodrich: tightening of check for resume on a disabled process to
1.35         (acg      08-Mar-11): //  only produce an error if it is ready to run.
1.35         (acg      08-Mar-11): //
1.34         (acg      07-Mar-11): // Revision 1.33  2011/03/07 17:38:44  acg
1.34         (acg      07-Mar-11): //  Andy Goodrich: tightening up of checks for undefined interaction between
1.34         (acg      07-Mar-11): //  synchronous reset and suspend.
1.34         (acg      07-Mar-11): //
1.33         (acg      07-Mar-11): // Revision 1.32  2011/03/06 23:30:13  acg
1.33         (acg      07-Mar-11): //  Andy Goodrich: refining suspend - sync reset corner case checking so that
1.33         (acg      07-Mar-11): //  the following are error situations:
1.33         (acg      07-Mar-11): //    (1) Calling suspend on a process with a reset_signal_is() specification
1.33         (acg      07-Mar-11): //        or sync_reset_on() is active.
1.33         (acg      07-Mar-11): //    (2) Calling sync_reset_on() on a suspended process.
1.33         (acg      07-Mar-11): //
1.32         (acg      06-Mar-11): // Revision 1.31  2011/03/06 19:57:11  acg
1.32         (acg      06-Mar-11): //  Andy Goodrich: refinements for the illegal suspend - synchronous reset
1.32         (acg      06-Mar-11): //  interaction.
1.32         (acg      06-Mar-11): //
1.31         (acg      06-Mar-11): // Revision 1.30  2011/03/06 16:47:09  acg
1.31         (acg      06-Mar-11): //  Andy Goodrich: changes for testing sync_reset - suspend corner cases.
1.31         (acg      06-Mar-11): //
1.30         (acg      06-Mar-11): // Revision 1.29  2011/03/06 15:59:23  acg
1.30         (acg      06-Mar-11): //  Andy Goodrich: added process control corner case checks.
1.30         (acg      06-Mar-11): //
1.29         (acg      06-Mar-11): // Revision 1.28  2011/03/05 19:44:20  acg
1.29         (acg      06-Mar-11): //  Andy Goodrich: changes for object and event naming and structures.
1.29         (acg      06-Mar-11): //
1.28         (acg      05-Mar-11): // Revision 1.27  2011/02/19 08:30:53  acg
1.28         (acg      05-Mar-11): //  Andy Goodrich: Moved process queueing into trigger_static from
1.28         (acg      05-Mar-11): //  sc_event::notify.
1.28         (acg      05-Mar-11): //
1.27         (acg      19-Feb-11): // Revision 1.26  2011/02/18 20:27:14  acg
1.27         (acg      19-Feb-11): //  Andy Goodrich: Updated Copyrights.
1.27         (acg      19-Feb-11): //
1.26         (acg      18-Feb-11): // Revision 1.25  2011/02/17 19:54:33  acg
1.26         (acg      18-Feb-11): //  Andy Goodrich:
1.26         (acg      18-Feb-11): //    (1) Changed signature of trigger_dynamic() back to bool, and moved
1.26         (acg      18-Feb-11): //        run queue processing into trigger_dynamic.
1.26         (acg      18-Feb-11): //    (2) Simplified process control usage.
1.26         (acg      18-Feb-11): //
1.25         (acg      17-Feb-11): // Revision 1.24  2011/02/16 22:37:31  acg
1.25         (acg      17-Feb-11): //  Andy Goodrich: clean up to remove need for ps_disable_pending.
1.25         (acg      17-Feb-11): //
1.24         (acg      16-Feb-11): // Revision 1.23  2011/02/14 17:51:40  acg
1.24         (acg      16-Feb-11): //  Andy Goodrich: proper pushing an poppping of the module hierarchy for
1.24         (acg      16-Feb-11): //  start_of_simulation() and end_of_simulation.
1.24         (acg      16-Feb-11): //
1.23         (acg      14-Feb-11): // Revision 1.22  2011/02/13 23:09:58  acg
1.23         (acg      14-Feb-11): //  Andy Goodrich: only remove dynamic events for asynchronous resets.
1.23         (acg      14-Feb-11): //
1.22         (acg      13-Feb-11): // Revision 1.21  2011/02/13 21:47:38  acg
1.22         (acg      13-Feb-11): //  Andy Goodrich: update copyright notice.
1.22         (acg      13-Feb-11): //
1.21         (acg      13-Feb-11): // Revision 1.20  2011/02/13 21:37:13  acg
1.21         (acg      13-Feb-11): //  Andy Goodrich: removed temporary diagnostic. Also there is
1.21         (acg      13-Feb-11): //  remove_dynamic_events() call in reset code.
1.21         (acg      13-Feb-11): //
1.20         (acg      13-Feb-11): // Revision 1.19  2011/02/13 21:35:09  acg
1.20         (acg      13-Feb-11): //  Andy Goodrich: added error messages for throws before the simulator is
1.20         (acg      13-Feb-11): //  initialized.
1.20         (acg      13-Feb-11): //
1.19         (acg      13-Feb-11): // Revision 1.18  2011/02/11 13:25:24  acg
1.19         (acg      13-Feb-11): //  Andy Goodrich: Philipp A. Hartmann's changes:
1.19         (acg      13-Feb-11): //    (1) Removal of SC_CTHREAD method overloads.
1.19         (acg      13-Feb-11): //    (2) New exception processing code.
1.19         (acg      13-Feb-11): //
1.18         (acg      11-Feb-11): // Revision 1.17  2011/02/08 08:18:16  acg
1.18         (acg      11-Feb-11): //  Andy Goodrich: removed obsolete code.
1.18         (acg      11-Feb-11): //
1.17         (acg      08-Feb-11): // Revision 1.16  2011/02/07 19:17:20  acg
1.17         (acg      08-Feb-11): //  Andy Goodrich: changes for IEEE 1666 compatibility.
1.17         (acg      08-Feb-11): //
1.16         (acg      07-Feb-11): // Revision 1.15  2011/02/04 15:27:36  acg
1.16         (acg      07-Feb-11): //  Andy Goodrich: changes for suspend-resume semantics.
1.16         (acg      07-Feb-11): //
1.15         (acg      04-Feb-11): // Revision 1.14  2011/02/01 23:01:53  acg
1.15         (acg      04-Feb-11): //  Andy Goodrich: removed dead code.
1.15         (acg      04-Feb-11): //
1.14         (acg      01-Feb-11): // Revision 1.13  2011/02/01 21:16:36  acg
1.14         (acg      01-Feb-11): //  Andy Goodrich:
1.14         (acg      01-Feb-11): //  (1) New version of trigger_dynamic() to implement new return codes and
1.14         (acg      01-Feb-11): //      proper processing of events with new dynamic process rules.
1.14         (acg      01-Feb-11): //  (2) Recoding of kill_process(), throw_user() and reset support to
1.14         (acg      01-Feb-11): //      consolidate preemptive thread execution in sc_simcontext::preempt_with().
1.14         (acg      01-Feb-11): //
1.13         (acg      01-Feb-11): // Revision 1.12  2011/01/25 20:50:37  acg
1.13         (acg      01-Feb-11): //  Andy Goodrich: changes for IEEE 1666 2011.
1.13         (acg      01-Feb-11): //
1.12         (acg      25-Jan-11): // Revision 1.11  2011/01/20 16:52:20  acg
1.12         (acg      25-Jan-11): //  Andy Goodrich: changes for IEEE 1666 2011.
1.12         (acg      25-Jan-11): //
1.11         (acg      20-Jan-11): // Revision 1.10  2011/01/19 23:21:50  acg
1.11         (acg      20-Jan-11): //  Andy Goodrich: changes for IEEE 1666 2011
1.11         (acg      20-Jan-11): //
1.10         (acg      19-Jan-11): // Revision 1.9  2011/01/18 20:10:45  acg
1.10         (acg      19-Jan-11): //  Andy Goodrich: changes for IEEE1666_2011 semantics.
1.10         (acg      19-Jan-11): //
1.9          (acg      18-Jan-11): // Revision 1.8  2011/01/06 18:02:16  acg
1.9          (acg      18-Jan-11): //  Andy Goodrich: added check for disabled thread to trigger_dynamic().
1.9          (acg      18-Jan-11): //
1.8          (acg      06-Jan-11): // Revision 1.7  2010/11/20 17:10:57  acg
1.8          (acg      06-Jan-11): //  Andy Goodrich: reset processing changes for new IEEE 1666 standard.
1.8          (acg      06-Jan-11): //
1.7          (acg      20-Nov-10): // Revision 1.6  2010/07/22 20:02:33  acg
1.7          (acg      20-Nov-10): //  Andy Goodrich: bug fixes.
1.7          (acg      20-Nov-10): //
1.6          (acg      22-Jul-10): // Revision 1.5  2009/07/28 01:10:53  acg
1.6          (acg      22-Jul-10): //  Andy Goodrich: updates for 2.3 release candidate.
1.6          (acg      22-Jul-10): //
1.5          (acg      28-Jul-09): // Revision 1.4  2009/05/22 16:06:29  acg
1.5          (acg      28-Jul-09): //  Andy Goodrich: process control updates.
1.5          (acg      28-Jul-09): //
1.4          (acg      22-May-09): // Revision 1.3  2008/05/22 17:06:06  acg
1.4          (acg      22-May-09): //  Andy Goodrich: formatting and comments.
1.4          (acg      22-May-09): //
1.3          (acg      22-May-08): // Revision 1.2  2007/09/20 20:32:35  acg
1.3          (acg      22-May-08): //  Andy Goodrich: changes to the semantics of throw_it() to match the
1.3          (acg      22-May-08): //  specification. A call to throw_it() will immediately suspend the calling
1.3          (acg      22-May-08): //  thread until all the throwees have executed. At that point the calling
1.3          (acg      22-May-08): //  thread will be restarted before the execution of any other threads.
1.3          (acg      22-May-08): //
1.2          (acg      20-Sep-07): // Revision 1.1.1.1  2006/12/15 20:20:05  acg
1.2          (acg      20-Sep-07): // SystemC 2.3
1.2          (acg      20-Sep-07): //
1.1          (acg      15-Dec-06): // Revision 1.8  2006/04/20 17:08:17  acg
1.1          (acg      15-Dec-06): //  Andy Goodrich: 3.0 style process changes.
1.1          (acg      15-Dec-06): //
1.1          (acg      15-Dec-06): // Revision 1.7  2006/04/11 23:13:21  acg
1.1          (acg      15-Dec-06): //   Andy Goodrich: Changes for reduced reset support that only includes
1.1          (acg      15-Dec-06): //   sc_cthread, but has preliminary hooks for expanding to method and thread
1.1          (acg      15-Dec-06): //   processes also.
1.1          (acg      15-Dec-06): //
1.1          (acg      15-Dec-06): // Revision 1.6  2006/03/21 00:00:34  acg
1.1          (acg      15-Dec-06): //   Andy Goodrich: changed name of sc_get_current_process_base() to be
1.1          (acg      15-Dec-06): //   sc_get_current_process_b() since its returning an sc_process_b instance.
1.1          (acg      15-Dec-06): //
1.1          (acg      15-Dec-06): // Revision 1.5  2006/01/26 21:04:55  acg
1.1          (acg      15-Dec-06): //  Andy Goodrich: deprecation message changes and additional messages.
1.1          (acg      15-Dec-06): //
1.1          (acg      15-Dec-06): // Revision 1.4  2006/01/24 20:49:05  acg
1.1          (acg      15-Dec-06): // Andy Goodrich: changes to remove the use of deprecated features within the
1.1          (acg      15-Dec-06): // simulator, and to issue warning messages when deprecated features are used.
1.1          (acg      15-Dec-06): //
1.1          (acg      15-Dec-06): // Revision 1.3  2006/01/13 18:44:30  acg
1.1          (acg      15-Dec-06): // Added $Log to record CVS changes into the source.
1.1          (acg      15-Dec-06): //
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): #include "sysc/kernel/sc_thread_process.h"
1.1          (acg      15-Dec-06): #include "sysc/kernel/sc_process_handle.h"
1.1          (acg      15-Dec-06): #include "sysc/kernel/sc_simcontext_int.h"
1.1          (acg      15-Dec-06): #include "sysc/kernel/sc_module.h"
1.1          (acg      15-Dec-06): 
1.43         (acg      10-Apr-11): // DEBUGGING MACROS:
1.43         (acg      10-Apr-11): //
1.43         (acg      10-Apr-11): // DEBUG_MSG(NAME,P,MSG)
1.43         (acg      10-Apr-11): //     MSG  = message to print
1.43         (acg      10-Apr-11): //     NAME = name that must match the process for the message to print, or
1.43         (acg      10-Apr-11): //            null if the message should be printed unconditionally.
1.43         (acg      10-Apr-11): //     P    = pointer to process message is for, or NULL in which case the
1.43         (acg      10-Apr-11): //            message will not print.
1.43         (acg      10-Apr-11): #if 0
1.43         (acg      10-Apr-11): #   define DEBUG_NAME (const char*)0
1.43         (acg      10-Apr-11): #   define DEBUG_MSG(NAME,P,MSG) \
1.43         (acg      10-Apr-11):     { \
1.43         (acg      10-Apr-11):         if ( P && ( (NAME==0) || !strcmp(NAME,P->name())) ) \
1.43         (acg      10-Apr-11):           std::cout << sc_time_stamp() << ": " << P->name() << " ******** " \
1.43         (acg      10-Apr-11):                     << MSG << std::endl; \
1.43         (acg      10-Apr-11):     }
1.43         (acg      10-Apr-11): #else
1.43         (acg      10-Apr-11): #   define DEBUG_MSG(NAME,P,MSG) 
1.43         (acg      10-Apr-11): #endif
1.43         (acg      10-Apr-11): 
1.1          (acg      15-Dec-06): namespace sc_core {
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): //"sc_thread_cor_fn"
1.1          (acg      15-Dec-06): // 
1.1          (acg      15-Dec-06): // This function invokes the coroutine for the supplied object instance.
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): void sc_thread_cor_fn( void* arg )
1.1          (acg      15-Dec-06): {
1.4          (acg      22-May-09):     sc_simcontext*   simc_p = sc_get_curr_simcontext();
1.1          (acg      15-Dec-06):     sc_thread_handle thread_h = RCAST<sc_thread_handle>( arg );
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):     // PROCESS THE THREAD AND PROCESS ANY EXCEPTIONS THAT ARE THROWN:
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):     while( true ) {
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):         try {
1.1          (acg      15-Dec-06):             thread_h->semantics();
1.1          (acg      15-Dec-06):         }
1.1          (acg      15-Dec-06):         catch( sc_user ) {
1.1          (acg      15-Dec-06):             continue;
1.1          (acg      15-Dec-06):         }
1.1          (acg      15-Dec-06):         catch( sc_halt ) {
1.1          (acg      15-Dec-06):             ::std::cout << "Terminating process "
1.1          (acg      15-Dec-06):                       << thread_h->name() << ::std::endl;
1.1          (acg      15-Dec-06):         }
1.9          (acg      18-Jan-11):         catch( const sc_unwind_exception& ex ) {
1.18         (acg      11-Feb-11): 	    ex.clear();
1.18         (acg      11-Feb-11):             if ( ex.is_reset() ) continue;
1.5          (acg      28-Jul-09):         }
1.1          (acg      15-Dec-06):         catch( const sc_report& ex ) {
1.1          (acg      15-Dec-06):             std::cout << "\n" << ex.what() << std::endl;
1.1          (acg      15-Dec-06):             thread_h->simcontext()->set_error();
1.1          (acg      15-Dec-06):         }
1.1          (acg      15-Dec-06):         break;
1.1          (acg      15-Dec-06):     }
1.1          (acg      15-Dec-06): 
1.4          (acg      22-May-09):     sc_process_b*    active_p = sc_get_current_process_b();
1.4          (acg      22-May-09): 
1.4          (acg      22-May-09):     // REMOVE ALL TRACES OF OUR THREAD FROM THE SIMULATORS DATA STRUCTURES:
1.4          (acg      22-May-09): 
1.4          (acg      22-May-09):     thread_h->disconnect_process();
1.4          (acg      22-May-09): 
1.4          (acg      22-May-09):     // IF WE AREN'T ACTIVE MAKE SURE WE WON'T EXECUTE:
1.4          (acg      22-May-09): 
1.4          (acg      22-May-09):     if ( thread_h->next_runnable() != 0 )
1.4          (acg      22-May-09):     {
1.4          (acg      22-May-09): 	simc_p->remove_runnable_thread(thread_h);
1.4          (acg      22-May-09):     }
1.4          (acg      22-May-09): 
1.4          (acg      22-May-09):     // IF WE ARE THE ACTIVE PROCESS ABORT OUR EXECUTION:
1.4          (acg      22-May-09): 
1.4          (acg      22-May-09): 
1.4          (acg      22-May-09):     if ( active_p == (sc_process_b*)thread_h )
1.4          (acg      22-May-09):     {
1.4          (acg      22-May-09):      
1.4          (acg      22-May-09):         sc_core::sc_cor* x = simc_p->next_cor();
1.4          (acg      22-May-09): 	simc_p->cor_pkg()->abort( x );
1.4          (acg      22-May-09):     }
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): }
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): //"sc_thread_process::disable_process"
1.1          (acg      15-Dec-06): //
1.1          (acg      15-Dec-06): // This virtual method suspends this process and its children if requested to.
1.1          (acg      15-Dec-06): //     descendants = indicator of whether this process' children should also
1.1          (acg      15-Dec-06): //                   be suspended
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): void sc_thread_process::disable_process(
1.1          (acg      15-Dec-06):     sc_descendant_inclusion_info descendants )
1.1          (acg      15-Dec-06): {     
1.1          (acg      15-Dec-06):     int                              child_i;    // Index of child accessing.
1.1          (acg      15-Dec-06):     int                              child_n;    // Number of children.
1.1          (acg      15-Dec-06):     sc_process_b*                    child_p;    // Child accessing.
1.1          (acg      15-Dec-06):     const ::std::vector<sc_object*>* children_p; // Vector of children.
1.1          (acg      15-Dec-06): 
1.4          (acg      22-May-09):     // IF NEEDED PROPOGATE THE DISABLE REQUEST THROUGH OUR DESCENDANTS:
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):     if ( descendants == SC_INCLUDE_DESCENDANTS )
1.1          (acg      15-Dec-06):     {
1.1          (acg      15-Dec-06):         children_p = &get_child_objects();
1.1          (acg      15-Dec-06):         child_n = children_p->size();
1.1          (acg      15-Dec-06):         for ( child_i = 0; child_i < child_n; child_i++ )
1.1          (acg      15-Dec-06):         {
1.1          (acg      15-Dec-06):             child_p = DCAST<sc_process_b*>((*children_p)[child_i]);
1.1          (acg      15-Dec-06):             if ( child_p ) child_p->disable_process(descendants);
1.1          (acg      15-Dec-06):         }
1.1          (acg      15-Dec-06):     }
1.1          (acg      15-Dec-06): 
1.29         (acg      06-Mar-11):     // DON'T ALLOW CORNER CASE BY DEFAULT:
1.29         (acg      06-Mar-11): 
1.29         (acg      06-Mar-11):     if ( !sc_allow_process_control_corners )
1.36         (acg      08-Mar-11):     {
1.36         (acg      08-Mar-11): 	switch( m_trigger_type )
1.36         (acg      08-Mar-11): 	{ 
1.36         (acg      08-Mar-11): 	  case AND_LIST_TIMEOUT:
1.36         (acg      08-Mar-11): 	  case EVENT_TIMEOUT: 
1.36         (acg      08-Mar-11): 	  case OR_LIST_TIMEOUT:
1.36         (acg      08-Mar-11): 	  case TIMEOUT:
1.43         (acg      10-Apr-11): 	    SC_REPORT_ERROR(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
1.43         (acg      10-Apr-11): 		            ": attempt to disable a thread with timeout wait");
1.36         (acg      08-Mar-11): 	    break;
1.36         (acg      08-Mar-11): 	  default:
1.36         (acg      08-Mar-11): 	    break;
1.36         (acg      08-Mar-11): 	}
1.29         (acg      06-Mar-11):     }
1.29         (acg      06-Mar-11): 
1.25         (acg      17-Feb-11):     // DISABLE OUR OBJECT INSTANCE:
1.1          (acg      15-Dec-06): 
1.25         (acg      17-Feb-11):     m_state = m_state | ps_bit_disabled; 
1.38         (acg      23-Mar-11): 
1.38         (acg      23-Mar-11):     // IF THIS CALL IS BEFORE THE SIMULATION DON'T RUN THE THREAD:
1.38         (acg      23-Mar-11): 
1.43         (acg      10-Apr-11):     if ( !sc_is_running() ) 
1.38         (acg      23-Mar-11):     {
1.43         (acg      10-Apr-11): 	m_state = m_state | ps_bit_ready_to_run;
1.38         (acg      23-Mar-11):         simcontext()->remove_runnable_thread(this);
1.38         (acg      23-Mar-11):     }
1.1          (acg      15-Dec-06): }
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): //"sc_thread_process::enable_process"
1.1          (acg      15-Dec-06): //
1.1          (acg      15-Dec-06): // This method resumes the execution of this process, and if requested, its
1.1          (acg      15-Dec-06): // descendants. If the process was suspended and has a resumption pending it 
1.1          (acg      15-Dec-06): // will be dispatched in the next delta cycle. Otherwise the state will be
1.1          (acg      15-Dec-06): // adjusted to indicate it is no longer suspended, but no immediate execution
1.1          (acg      15-Dec-06): // will occur.
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): void sc_thread_process::enable_process(
1.1          (acg      15-Dec-06):     sc_descendant_inclusion_info descendants )
1.1          (acg      15-Dec-06): {
1.1          (acg      15-Dec-06):     int                              child_i;    // Index of child accessing.
1.1          (acg      15-Dec-06):     int                              child_n;    // Number of children.
1.1          (acg      15-Dec-06):     sc_process_b*                    child_p;    // Child accessing.
1.1          (acg      15-Dec-06):     const ::std::vector<sc_object*>* children_p; // Vector of children.
1.1          (acg      15-Dec-06): 
1.4          (acg      22-May-09):     // IF NEEDED PROPOGATE THE ENABLE REQUEST THROUGH OUR DESCENDANTS:
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):     if ( descendants == SC_INCLUDE_DESCENDANTS )
1.1          (acg      15-Dec-06):     {
1.1          (acg      15-Dec-06):         children_p = &get_child_objects();
1.1          (acg      15-Dec-06):         child_n = children_p->size();
1.1          (acg      15-Dec-06):         for ( child_i = 0; child_i < child_n; child_i++ )
1.1          (acg      15-Dec-06):         {
1.1          (acg      15-Dec-06):             child_p = DCAST<sc_process_b*>((*children_p)[child_i]);
1.1          (acg      15-Dec-06):             if ( child_p ) child_p->enable_process(descendants);
1.1          (acg      15-Dec-06):         }
1.1          (acg      15-Dec-06):     }
1.1          (acg      15-Dec-06): 
1.25         (acg      17-Feb-11):     // ENABLE THIS OBJECT INSTANCE:
1.25         (acg      17-Feb-11):     //
1.25         (acg      17-Feb-11):     // If it was disabled and ready to run then put it on the run queue.
1.1          (acg      15-Dec-06): 
1.25         (acg      17-Feb-11):     m_state = m_state & ~ps_bit_disabled; 
1.44         (acg      11-Apr-11):     if ( m_state == ps_bit_ready_to_run && sc_allow_process_control_corners )
1.1          (acg      15-Dec-06):     {
1.13         (acg      01-Feb-11):         m_state = ps_normal;
1.13         (acg      01-Feb-11): 	if ( next_runnable() == 0 )
1.13         (acg      01-Feb-11): 	    simcontext()->push_runnable_thread(this);
1.3          (acg      22-May-08):     }
1.1          (acg      15-Dec-06): }
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): //"sc_thread_process::kill_process"
1.1          (acg      15-Dec-06): //
1.1          (acg      15-Dec-06): // This method removes this object instance from use. It calls the
1.1          (acg      15-Dec-06): // sc_process_b::kill_process() method to perform low level clean up. Then
1.1          (acg      15-Dec-06): // it aborts this process if it is the active process.
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): void sc_thread_process::kill_process(sc_descendant_inclusion_info descendants )
1.1          (acg      15-Dec-06): {
1.10         (acg      19-Jan-11):     int                              child_i;    // index of child accessing.
1.10         (acg      19-Jan-11):     int                              child_n;    // number of children.
1.10         (acg      19-Jan-11):     sc_process_b*                    child_p;    // child accessing.
1.10         (acg      19-Jan-11):     const ::std::vector<sc_object*>* children_p; // vector of children.
1.11         (acg      20-Jan-11):     sc_simcontext*                   context_p;  // current simulation context.
1.11         (acg      20-Jan-11): 
1.19         (acg      13-Feb-11):     // IF THE SIMULATION HAS NOT BEEN INITIALIZED YET THAT IS AN ERROR:
1.19         (acg      13-Feb-11): 
1.40         (acg      05-Apr-11):     if ( !sc_is_running() )
1.19         (acg      13-Feb-11):     {
1.19         (acg      13-Feb-11):         SC_REPORT_ERROR( SC_KILL_PROCESS_WHILE_UNITIALIZED_, "" );
1.19         (acg      13-Feb-11):     }
1.19         (acg      13-Feb-11): 
1.11         (acg      20-Jan-11):     context_p = simcontext();
1.4          (acg      22-May-09): 
1.4          (acg      22-May-09):     // IF NEEDED PROPOGATE THE KILL REQUEST THROUGH OUR DESCENDANTS:
1.1          (acg      15-Dec-06): 
1.4          (acg      22-May-09):     if ( descendants == SC_INCLUDE_DESCENDANTS )
1.4          (acg      22-May-09):     {
1.4          (acg      22-May-09):         children_p = &get_child_objects();
1.4          (acg      22-May-09):         child_n = children_p->size();
1.4          (acg      22-May-09):         for ( child_i = 0; child_i < child_n; child_i++ )
1.4          (acg      22-May-09):         {
1.4          (acg      22-May-09):             child_p = DCAST<sc_process_b*>((*children_p)[child_i]);
1.4          (acg      22-May-09):             if ( child_p ) child_p->kill_process(descendants);
1.4          (acg      22-May-09):         }
1.1          (acg      15-Dec-06):     }
1.1          (acg      15-Dec-06): 
1.4          (acg      22-May-09):     // SET UP TO KILL THE PROCESS IF SIMULATION HAS STARTED:
1.13         (acg      01-Feb-11): 
1.4          (acg      22-May-09):     if ( sc_is_running() )
1.1          (acg      15-Dec-06):     {
1.13         (acg      01-Feb-11):         m_throw_status = THROW_KILL;
1.4          (acg      22-May-09):         m_wait_cycle_n = 0;
1.13         (acg      01-Feb-11):         context_p->preempt_with(this);
1.1          (acg      15-Dec-06):     }
1.6          (acg      22-Jul-10): 
1.10         (acg      19-Jan-11):     // IF THE SIMULATION HAS NOT STARTED REMOVE TRACES OF OUR PROCESS FROM 
1.10         (acg      19-Jan-11):     // EVENT QUEUES, ETC.:
1.6          (acg      22-Jul-10): 
1.6          (acg      22-Jul-10):     else
1.6          (acg      22-Jul-10):     {
1.6          (acg      22-Jul-10):         disconnect_process();
1.6          (acg      22-Jul-10):     }
1.1          (acg      15-Dec-06): }
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): //"sc_thread_process::prepare_for_simulation"
1.1          (acg      15-Dec-06): //
1.1          (acg      15-Dec-06): // This method prepares this object instance for simulation. It calls the
1.1          (acg      15-Dec-06): // coroutine package to create the actual thread.
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): void sc_thread_process::prepare_for_simulation()
1.1          (acg      15-Dec-06): {
1.1          (acg      15-Dec-06):     m_cor_p = simcontext()->cor_pkg()->create( m_stack_size,
1.1          (acg      15-Dec-06):                          sc_thread_cor_fn, this );
1.1          (acg      15-Dec-06):     m_cor_p->stack_protect( true );
1.1          (acg      15-Dec-06): }
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): //"sc_thread_process::resume_process"
1.1          (acg      15-Dec-06): //
1.1          (acg      15-Dec-06): // This method resumes the execution of this process, and if requested, its
1.1          (acg      15-Dec-06): // descendants. If the process was suspended and has a resumption pending it 
1.1          (acg      15-Dec-06): // will be dispatched in the next delta cycle. Otherwise the state will be
1.1          (acg      15-Dec-06): // adjusted to indicate it is no longer suspended, but no immediate execution
1.1          (acg      15-Dec-06): // will occur.
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): void sc_thread_process::resume_process(
1.1          (acg      15-Dec-06):     sc_descendant_inclusion_info descendants )
1.1          (acg      15-Dec-06): {
1.1          (acg      15-Dec-06):     int                              child_i;    // Index of child accessing.
1.1          (acg      15-Dec-06):     int                              child_n;    // Number of children.
1.1          (acg      15-Dec-06):     sc_process_b*                    child_p;    // Child accessing.
1.1          (acg      15-Dec-06):     const ::std::vector<sc_object*>* children_p; // Vector of children.
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):     // IF NEEDED PROPOGATE THE RESUME REQUEST THROUGH OUR DESCENDANTS:
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):     if ( descendants == SC_INCLUDE_DESCENDANTS )
1.1          (acg      15-Dec-06):     {
1.1          (acg      15-Dec-06):         children_p = &get_child_objects();
1.1          (acg      15-Dec-06):         child_n = children_p->size();
1.1          (acg      15-Dec-06):         for ( child_i = 0; child_i < child_n; child_i++ )
1.1          (acg      15-Dec-06):         {
1.1          (acg      15-Dec-06):             child_p = DCAST<sc_process_b*>((*children_p)[child_i]);
1.1          (acg      15-Dec-06):             if ( child_p ) child_p->resume_process(descendants);
1.1          (acg      15-Dec-06):         }
1.1          (acg      15-Dec-06):     }
1.1          (acg      15-Dec-06): 
1.37         (acg      20-Mar-11):     // BY DEFAULT THE CORNER CASE IS AN ERROR:
1.29         (acg      06-Mar-11): 
1.38         (acg      23-Mar-11):     if ( !sc_allow_process_control_corners && (m_state & ps_bit_disabled) &&
1.38         (acg      23-Mar-11):          (m_state & ps_bit_suspended) )
1.29         (acg      06-Mar-11):     {
1.38         (acg      23-Mar-11): 	m_state = m_state & ~ps_bit_suspended;
1.34         (acg      07-Mar-11):         SC_REPORT_ERROR(SC_ID_PROCESS_CONTROL_CORNER_CASE_, 
1.38         (acg      23-Mar-11): 	               ": call to resume() on a disabled suspended thread");
1.29         (acg      06-Mar-11):     }
1.29         (acg      06-Mar-11): 
1.38         (acg      23-Mar-11):     // CLEAR THE SUSPENDED BIT:
1.38         (acg      23-Mar-11): 
1.38         (acg      23-Mar-11):     m_state = m_state & ~ps_bit_suspended;
1.38         (acg      23-Mar-11): 
1.37         (acg      20-Mar-11):     // RESUME OBJECT INSTANCE IF IT IS READY TO RUN:
1.1          (acg      15-Dec-06): 
1.29         (acg      06-Mar-11):     if ( m_state & ps_bit_ready_to_run )
1.1          (acg      15-Dec-06):     {
1.29         (acg      06-Mar-11): 	m_state = m_state & ~ps_bit_ready_to_run;
1.25         (acg      17-Feb-11): 	if ( next_runnable() == 0 )  
1.25         (acg      17-Feb-11): 	    simcontext()->push_runnable_thread(this);
1.25         (acg      17-Feb-11): 	remove_dynamic_events();  // order important.
1.3          (acg      22-May-08):     }
1.1          (acg      15-Dec-06): }
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): //"sc_thread_process::sc_thread_process"
1.1          (acg      15-Dec-06): //
1.1          (acg      15-Dec-06): // This is the object instance constructor for this class.
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): sc_thread_process::sc_thread_process( const char* name_p, bool free_host,
1.1          (acg      15-Dec-06):     SC_ENTRY_FUNC method_p, sc_process_host* host_p, 
1.1          (acg      15-Dec-06):     const sc_spawn_options* opt_p 
1.1          (acg      15-Dec-06): ):
1.1          (acg      15-Dec-06):     sc_process_b(
1.28         (acg      05-Mar-11):         name_p ? name_p : sc_gen_unique_name("thread_p"), 
1.15         (acg      04-Feb-11):         true, free_host, method_p, host_p, opt_p),
1.28         (acg      05-Mar-11):     m_cor_p(0), m_stack_size(SC_DEFAULT_STACK_SIZE), 
1.28         (acg      05-Mar-11):     m_wait_cycle_n(0)
1.1          (acg      15-Dec-06): {
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):     // CHECK IF THIS IS AN sc_module-BASED PROCESS AND SIMUALTION HAS STARTED:
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):     if ( DCAST<sc_module*>(host_p) != 0 && sc_is_running() )
1.1          (acg      15-Dec-06):     {
1.1          (acg      15-Dec-06):         SC_REPORT_ERROR( SC_ID_MODULE_THREAD_AFTER_START_, "" );
1.1          (acg      15-Dec-06):     }
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):     // INITIALIZE VALUES:
1.1          (acg      15-Dec-06):     //
1.1          (acg      15-Dec-06):     // If there are spawn options use them.
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):     m_process_kind = SC_THREAD_PROC_;
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):     if (opt_p) {
1.1          (acg      15-Dec-06):         m_dont_init = opt_p->m_dont_initialize;
1.1          (acg      15-Dec-06):         if ( opt_p->m_stack_size ) m_stack_size = opt_p->m_stack_size;
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):         // traverse event sensitivity list
1.1          (acg      15-Dec-06):         for (unsigned int i = 0; i < opt_p->m_sensitive_events.size(); i++) {
1.1          (acg      15-Dec-06):             sc_sensitive::make_static_sensitivity(
1.1          (acg      15-Dec-06):                 this, *opt_p->m_sensitive_events[i]);
1.1          (acg      15-Dec-06):         }
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):         // traverse port base sensitivity list
1.1          (acg      15-Dec-06):         for ( unsigned int i = 0; i < opt_p->m_sensitive_port_bases.size(); i++)
1.1          (acg      15-Dec-06):         {
1.1          (acg      15-Dec-06):             sc_sensitive::make_static_sensitivity(
1.1          (acg      15-Dec-06):                 this, *opt_p->m_sensitive_port_bases[i]);
1.1          (acg      15-Dec-06):         }
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):         // traverse interface sensitivity list
1.1          (acg      15-Dec-06):         for ( unsigned int i = 0; i < opt_p->m_sensitive_interfaces.size(); i++)
1.1          (acg      15-Dec-06):         {
1.1          (acg      15-Dec-06):             sc_sensitive::make_static_sensitivity(
1.1          (acg      15-Dec-06):                 this, *opt_p->m_sensitive_interfaces[i]);
1.1          (acg      15-Dec-06):         }
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):         // traverse event finder sensitivity list
1.1          (acg      15-Dec-06):         for ( unsigned int i = 0; i < opt_p->m_sensitive_event_finders.size();
1.1          (acg      15-Dec-06):             i++)
1.1          (acg      15-Dec-06):         {
1.1          (acg      15-Dec-06):             sc_sensitive::make_static_sensitivity(
1.1          (acg      15-Dec-06):                 this, *opt_p->m_sensitive_event_finders[i]);
1.1          (acg      15-Dec-06):         }
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):         // process any reset signal specification:
1.7          (acg      20-Nov-10): 
1.7          (acg      20-Nov-10): 	opt_p->specify_resets();
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):     }
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):     else
1.1          (acg      15-Dec-06):     {
1.1          (acg      15-Dec-06):         m_dont_init = false;
1.1          (acg      15-Dec-06):     }
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): }
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): //"sc_thread_process::~sc_thread_process"
1.1          (acg      15-Dec-06): //
1.1          (acg      15-Dec-06): // This is the object instance constructor for this class.
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): sc_thread_process::~sc_thread_process()
1.1          (acg      15-Dec-06): {
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):     // DESTROY THE COROUTINE FOR THIS THREAD:
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):     if( m_cor_p != 0 ) {
1.1          (acg      15-Dec-06):         m_cor_p->stack_protect( false );
1.1          (acg      15-Dec-06):         delete m_cor_p;
1.1          (acg      15-Dec-06):         m_cor_p = 0;
1.1          (acg      15-Dec-06):     }
1.1          (acg      15-Dec-06): }
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): //"sc_thread_process::signal_monitors"
1.1          (acg      15-Dec-06): //
1.1          (acg      15-Dec-06): // This methods signals the list of monitors for this object instance.
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): void sc_thread_process::signal_monitors(int type)
1.1          (acg      15-Dec-06): {       
1.1          (acg      15-Dec-06):     int mon_n;  // # of monitors present.
1.1          (acg      15-Dec-06):         
1.1          (acg      15-Dec-06):     mon_n = m_monitor_q.size();
1.1          (acg      15-Dec-06):     for ( int mon_i = 0; mon_i < mon_n; mon_i++ )
1.1          (acg      15-Dec-06):         m_monitor_q[mon_i]->signal(this, type);
1.1          (acg      15-Dec-06): }   
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): //"sc_thread_process::suspend_process"
1.1          (acg      15-Dec-06): //
1.1          (acg      15-Dec-06): // This virtual method suspends this process and its children if requested to.
1.1          (acg      15-Dec-06): //     descendants = indicator of whether this process' children should also
1.1          (acg      15-Dec-06): //                   be suspended
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): void sc_thread_process::suspend_process(
1.1          (acg      15-Dec-06):     sc_descendant_inclusion_info descendants )
1.1          (acg      15-Dec-06): {     
1.1          (acg      15-Dec-06):     int                              child_i;    // Index of child accessing.
1.1          (acg      15-Dec-06):     int                              child_n;    // Number of children.
1.1          (acg      15-Dec-06):     sc_process_b*                    child_p;    // Child accessing.
1.1          (acg      15-Dec-06):     const ::std::vector<sc_object*>* children_p; // Vector of children.
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):     // IF NEEDED PROPOGATE THE SUSPEND REQUEST THROUGH OUR DESCENDANTS:
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06):     if ( descendants == SC_INCLUDE_DESCENDANTS )
1.1          (acg      15-Dec-06):     {
1.1          (acg      15-Dec-06):         children_p = &get_child_objects();
1.1          (acg      15-Dec-06):         child_n = children_p->size();
1.1          (acg      15-Dec-06):         for ( child_i = 0; child_i < child_n; child_i++ )
1.1          (acg      15-Dec-06):         {
1.1          (acg      15-Dec-06):             child_p = DCAST<sc_process_b*>((*children_p)[child_i]);
1.1          (acg      15-Dec-06):             if ( child_p ) child_p->suspend_process(descendants);
1.1          (acg      15-Dec-06):         }
1.1          (acg      15-Dec-06):     }
1.1          (acg      15-Dec-06): 
1.37         (acg      20-Mar-11):     // CORNER CASE CHECKS, THE FOLLOWING ARE ERRORS:
1.37         (acg      20-Mar-11):     //   (a) if this thread has a reset_signal_is specification 
1.37         (acg      20-Mar-11):     //   (b) if this thread is in synchronous reset
1.36         (acg      08-Mar-11): 
1.37         (acg      20-Mar-11):     if ( !sc_allow_process_control_corners && m_has_reset_signal )
1.36         (acg      08-Mar-11):     {
1.36         (acg      08-Mar-11): 	SC_REPORT_ERROR(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
1.37         (acg      20-Mar-11): 		    ": attempt to suspend a thread that has a reset signal");
1.37         (acg      20-Mar-11):     }
1.37         (acg      20-Mar-11):     else if ( !sc_allow_process_control_corners && m_sticky_reset )
1.37         (acg      20-Mar-11):     {
1.37         (acg      20-Mar-11): 	SC_REPORT_ERROR(SC_ID_PROCESS_CONTROL_CORNER_CASE_,
1.37         (acg      20-Mar-11): 		    ": attempt to suspend a thread in synchronous reset");
1.36         (acg      08-Mar-11):     }
1.36         (acg      08-Mar-11): 
1.1          (acg      15-Dec-06):     // SUSPEND OUR OBJECT INSTANCE:
1.3          (acg      22-May-08):     //
1.25         (acg      17-Feb-11):     // (1) If we are on the runnable queue then set suspended and ready_to_run,
1.25         (acg      17-Feb-11):     //     and remove ourselves from the run queue.
1.3          (acg      22-May-08):     // (2) If this is a self-suspension then a resume should cause immediate
1.25         (acg      17-Feb-11):     //     scheduling of the process, and we need to call suspend_me() here.
1.3          (acg      22-May-08): 
1.25         (acg      17-Feb-11):     m_state = m_state | ps_bit_suspended;
1.25         (acg      17-Feb-11):     if ( next_runnable() != 0 ) 
1.3          (acg      22-May-08):     {
1.25         (acg      17-Feb-11): 	m_state = m_state | ps_bit_ready_to_run;
1.25         (acg      17-Feb-11): 	simcontext()->remove_runnable_thread( this );
1.25         (acg      17-Feb-11):     }
1.25         (acg      17-Feb-11):     if ( sc_get_current_process_b() == DCAST<sc_process_b*>(this)  )
1.25         (acg      17-Feb-11):     {
1.25         (acg      17-Feb-11): 	m_state = m_state | ps_bit_ready_to_run;
1.25         (acg      17-Feb-11): 	suspend_me();
1.1          (acg      15-Dec-06):     }
1.1          (acg      15-Dec-06): }
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): //"sc_thread_process::throw_reset"
1.1          (acg      15-Dec-06): //
1.1          (acg      15-Dec-06): // This virtual method is invoked when an reset is to be thrown. The
1.1          (acg      15-Dec-06): // method will cancel any dynamic waits. If the reset is asynchronous it will 
1.1          (acg      15-Dec-06): // queue this object instance to be executed. 
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): void sc_thread_process::throw_reset( bool async )
1.1          (acg      15-Dec-06): {     
1.13         (acg      01-Feb-11):     // If the thread to be reset is dead ignore the call.
1.1          (acg      15-Dec-06): 
1.13         (acg      01-Feb-11):     if ( m_state & ps_bit_zombie ) return;
1.1          (acg      15-Dec-06): 
1.4          (acg      22-May-09): 
1.13         (acg      01-Feb-11):     // Set the throw type and clear any pending dynamic events: 
1.1          (acg      15-Dec-06): 
1.13         (acg      01-Feb-11):     m_throw_status = async ? THROW_ASYNC_RESET : THROW_SYNC_RESET;
1.1          (acg      15-Dec-06):     m_wait_cycle_n = 0;
1.4          (acg      22-May-09): 
1.41         (acg      08-Apr-11):     // If this is an asynchronous reset:
1.41         (acg      08-Apr-11):     //
1.41         (acg      08-Apr-11):     //   (a) Cancel any dynamic events 
1.41         (acg      08-Apr-11):     //   (b) Set the thread up for execution:
1.41         (acg      08-Apr-11):     //         (i) If we are in the execution phase do it now.
1.41         (acg      08-Apr-11):     //         (ii) If we are not queue it to execute next when we hit
1.41         (acg      08-Apr-11):     //              the execution phase.
1.4          (acg      22-May-09): 
1.22         (acg      13-Feb-11):     if ( async ) 
1.22         (acg      13-Feb-11):     {
1.23         (acg      14-Feb-11):         m_state = m_state & ~ps_bit_ready_to_run;
1.22         (acg      13-Feb-11):         remove_dynamic_events();
1.41         (acg      08-Apr-11): 	if ( simcontext()->evaluation_phase() )
1.41         (acg      08-Apr-11): 	{
1.41         (acg      08-Apr-11):             simcontext()->preempt_with( this );
1.41         (acg      08-Apr-11): 	}
1.41         (acg      08-Apr-11): 	else
1.41         (acg      08-Apr-11): 	{
1.41         (acg      08-Apr-11): 	    if ( is_runnable() )
1.41         (acg      08-Apr-11): 	        simcontext()->remove_runnable_thread(this);
1.41         (acg      08-Apr-11): 	    simcontext()->execute_thread_next(this);
1.41         (acg      08-Apr-11): 	}
1.22         (acg      13-Feb-11):     }
1.1          (acg      15-Dec-06): }
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): //"sc_thread_process::throw_user"
1.1          (acg      15-Dec-06): //
1.1          (acg      15-Dec-06): // This virtual method is invoked when a user exception is to be thrown.
1.1          (acg      15-Dec-06): // If requested it will also throw the exception to the children of this 
1.3          (acg      22-May-08): // object instance. The order of dispatch for the processes that are 
1.3          (acg      22-May-08): // thrown the exception is from youngest child to oldest child and then
1.3          (acg      22-May-08): // this process instance. This means that this instance will be pushed onto
1.3          (acg      22-May-08): // the front of the simulator's runnable queue and then the children will
1.3          (acg      22-May-08): // be processed recursively.
1.1          (acg      15-Dec-06): //     helper_p    =  helper object to use to throw the exception.
1.1          (acg      15-Dec-06): //     descendants =  indicator of whether this process' children should also
1.1          (acg      15-Dec-06): //                    be suspended
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): void sc_thread_process::throw_user( const sc_throw_it_helper& helper,
1.1          (acg      15-Dec-06):     sc_descendant_inclusion_info descendants )
1.1          (acg      15-Dec-06): {     
1.1          (acg      15-Dec-06):     int                              child_i;    // Index of child accessing.
1.1          (acg      15-Dec-06):     int                              child_n;    // Number of children.
1.1          (acg      15-Dec-06):     sc_process_b*                    child_p;    // Child accessing.
1.1          (acg      15-Dec-06):     const ::std::vector<sc_object*>* children_p; // Vector of children.
1.1          (acg      15-Dec-06): 
1.19         (acg      13-Feb-11):     // IF THE SIMULATION HAS NOT BEEN INITIALIZED YET THAT IS AN ERROR:
1.19         (acg      13-Feb-11): 
1.40         (acg      05-Apr-11):     if ( sc_get_status() != SC_RUNNING )
1.19         (acg      13-Feb-11):     {
1.40         (acg      05-Apr-11):         SC_REPORT_ERROR( SC_THROW_IT_WHILE_NOT_RUNNING_, name() );
1.19         (acg      13-Feb-11):     }
1.19         (acg      13-Feb-11): 
1.41         (acg      08-Apr-11):     // IF NEEDED PROPOGATE THE THROW REQUEST THROUGH OUR DESCENDANTS:
1.41         (acg      08-Apr-11): 
1.41         (acg      08-Apr-11):     if ( descendants == SC_INCLUDE_DESCENDANTS )
1.41         (acg      08-Apr-11):     {
1.41         (acg      08-Apr-11):         children_p = &get_child_objects();
1.41         (acg      08-Apr-11):         child_n = children_p->size();
1.41         (acg      08-Apr-11):         for ( child_i = 0; child_i < child_n; child_i++ )
1.41         (acg      08-Apr-11):         {
1.41         (acg      08-Apr-11):             child_p = DCAST<sc_process_b*>((*children_p)[child_i]);
1.41         (acg      08-Apr-11):             if ( child_p ) child_p->throw_user(helper, descendants);
1.41         (acg      08-Apr-11):         }
1.41         (acg      08-Apr-11):     }
1.3          (acg      22-May-08): 
1.3          (acg      22-May-08):     // SET UP THE THROW REQUEST FOR THIS OBJECT INSTANCE AND QUEUE IT FOR
1.3          (acg      22-May-08):     // EXECUTION:
1.3          (acg      22-May-08): 
1.43         (acg      10-Apr-11):     if ( m_state & ps_bit_zombie ) return;
1.3          (acg      22-May-08): 
1.43         (acg      10-Apr-11):     remove_dynamic_events();
1.44         (acg      11-Apr-11):     DEBUG_MSG(DEBUG_NAME,this,"throwing user exception");
1.43         (acg      10-Apr-11):     m_throw_status = THROW_USER;
1.43         (acg      10-Apr-11):     if ( m_throw_helper_p != 0 ) delete m_throw_helper_p;
1.43         (acg      10-Apr-11):     m_throw_helper_p = helper.clone();
1.43         (acg      10-Apr-11):     simcontext()->preempt_with( this );
1.1          (acg      15-Dec-06): }
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): //"sc_thread_process::trigger_dynamic"
1.1          (acg      15-Dec-06): //
1.13         (acg      01-Feb-11): // This method returns the status of this object instance with respect to 
1.13         (acg      01-Feb-11): // the supplied event. There are 3 potential values to return:
1.13         (acg      01-Feb-11): //   dt_rearm      - don't execute the thread and don't remove it from the
1.13         (acg      01-Feb-11): //                   event's queue.
1.13         (acg      01-Feb-11): //   dt_remove     - the thread should not be scheduled for execution and
1.13         (acg      01-Feb-11): //                   the process should be moved from the event's thread queue.
1.13         (acg      01-Feb-11): //   dt_run        - the thread should be scheduled for execution but the
1.13         (acg      01-Feb-11): //                   the proces should stay on the event's thread queue.
1.13         (acg      01-Feb-11): //   dt_run_remove - the thread should be scheduled for execution and the
1.13         (acg      01-Feb-11): //                   process should be removed from the event's thread queue.
1.13         (acg      01-Feb-11): //
1.13         (acg      01-Feb-11): // Notes:
1.13         (acg      01-Feb-11): //   (1) This method is identical to sc_method_process::trigger_dynamic(), 
1.13         (acg      01-Feb-11): //       but they cannot be combined as sc_process_b::trigger_dynamic() 
1.13         (acg      01-Feb-11): //       because the signatures things like sc_event::remove_dynamic()
1.13         (acg      01-Feb-11): //       have different overloads for sc_thread_process* and sc_method_process*.
1.13         (acg      01-Feb-11): //       So if you change code here you'll also need to change it in 
1.13         (acg      01-Feb-11): //       sc_method_process.cpp.
1.25         (acg      17-Feb-11): // Result is true if this process should be removed from the event's list,
1.25         (acg      17-Feb-11): // false if not.
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.25         (acg      17-Feb-11): bool sc_thread_process::trigger_dynamic( sc_event* e )
1.1          (acg      15-Dec-06): {
1.13         (acg      01-Feb-11):     // No time outs yet, and keep gcc happy.
1.13         (acg      01-Feb-11): 
1.13         (acg      01-Feb-11):     m_timed_out = false;
1.13         (acg      01-Feb-11): 
1.40         (acg      05-Apr-11):     // If this thread is already runnable then we are done, flush the event.
1.13         (acg      01-Feb-11): 
1.40         (acg      05-Apr-11):     if( is_runnable() )
1.13         (acg      01-Feb-11):     {
1.25         (acg      17-Feb-11):         return true;
1.1          (acg      15-Dec-06):     }
1.13         (acg      01-Feb-11): 
1.24         (acg      16-Feb-11):     // If a process is disabled then we ignore any events, leaving them enabled:
1.24         (acg      16-Feb-11):     //
1.24         (acg      16-Feb-11):     // But if this is a time out event we need to remove both it and the
1.24         (acg      16-Feb-11):     // event that was being waited for.
1.13         (acg      01-Feb-11): 
1.24         (acg      16-Feb-11):     if ( m_state & ps_bit_disabled )
1.9          (acg      18-Jan-11):     {
1.24         (acg      16-Feb-11):         if ( e == m_timeout_event_p )
1.13         (acg      01-Feb-11): 	{
1.26         (acg      18-Feb-11): 	    remove_dynamic_events( true );  
1.25         (acg      17-Feb-11): 	    return true;
1.13         (acg      01-Feb-11): 	}
1.13         (acg      01-Feb-11): 	else
1.13         (acg      01-Feb-11): 	{
1.25         (acg      17-Feb-11): 	    return false;
1.13         (acg      01-Feb-11): 	}
1.24         (acg      16-Feb-11):     }
1.24         (acg      16-Feb-11): 
1.24         (acg      16-Feb-11): 
1.24         (acg      16-Feb-11):     // Process based on the event type and current process state:
1.25         (acg      17-Feb-11):     //
1.25         (acg      17-Feb-11):     // Every case needs to set 'rc' and continue on to the end of
1.25         (acg      17-Feb-11):     // this method to allow suspend processing to work correctly.
1.24         (acg      16-Feb-11): 
1.24         (acg      16-Feb-11):     switch( m_trigger_type ) 
1.24         (acg      16-Feb-11):     {
1.24         (acg      16-Feb-11):       case EVENT: 
1.13         (acg      01-Feb-11): 	m_event_p = 0;
1.13         (acg      01-Feb-11): 	m_trigger_type = STATIC;
1.13         (acg      01-Feb-11): 	break;
1.13         (acg      01-Feb-11): 
1.13         (acg      01-Feb-11):       case AND_LIST:
1.13         (acg      01-Feb-11):         -- m_event_count;
1.13         (acg      01-Feb-11): 	if ( m_event_count == 0 )
1.13         (acg      01-Feb-11): 	{
1.13         (acg      01-Feb-11): 	    m_event_list_p->auto_delete();
1.13         (acg      01-Feb-11): 	    m_event_list_p = 0;
1.13         (acg      01-Feb-11): 	    m_trigger_type = STATIC;
1.13         (acg      01-Feb-11): 	}
1.13         (acg      01-Feb-11): 	else
1.13         (acg      01-Feb-11): 	{
1.25         (acg      17-Feb-11): 	    return true;
1.13         (acg      01-Feb-11): 	}
1.24         (acg      16-Feb-11): 	break;
1.13         (acg      01-Feb-11): 
1.24         (acg      16-Feb-11):       case OR_LIST:
1.13         (acg      01-Feb-11): 	m_event_list_p->remove_dynamic( this, e );
1.13         (acg      01-Feb-11): 	m_event_list_p->auto_delete();
1.13         (acg      01-Feb-11): 	m_event_list_p = 0;
1.13         (acg      01-Feb-11): 	m_trigger_type = STATIC;
1.13         (acg      01-Feb-11): 	break;
1.13         (acg      01-Feb-11): 
1.13         (acg      01-Feb-11):       case TIMEOUT: 
1.13         (acg      01-Feb-11): 	m_trigger_type = STATIC;
1.13         (acg      01-Feb-11): 	break;
1.13         (acg      01-Feb-11): 
1.13         (acg      01-Feb-11):       case EVENT_TIMEOUT: 
1.13         (acg      01-Feb-11):         if ( e == m_timeout_event_p )
1.13         (acg      01-Feb-11): 	{
1.13         (acg      01-Feb-11): 	    m_timed_out = true;
1.13         (acg      01-Feb-11): 	    m_event_p->remove_dynamic( this );
1.13         (acg      01-Feb-11): 	    m_event_p = 0;
1.13         (acg      01-Feb-11): 	    m_trigger_type = STATIC;
1.13         (acg      01-Feb-11): 	}
1.13         (acg      01-Feb-11): 	else
1.13         (acg      01-Feb-11): 	{
1.13         (acg      01-Feb-11): 	    m_timeout_event_p->cancel();
1.13         (acg      01-Feb-11): 	    m_timeout_event_p->reset();
1.13         (acg      01-Feb-11): 	    m_event_p = 0;
1.13         (acg      01-Feb-11): 	    m_trigger_type = STATIC;
1.13         (acg      01-Feb-11): 	}
1.13         (acg      01-Feb-11): 	break;
1.9          (acg      18-Jan-11): 
1.13         (acg      01-Feb-11):       case OR_LIST_TIMEOUT:
1.13         (acg      01-Feb-11):         if ( e == m_timeout_event_p )
1.13         (acg      01-Feb-11): 	{
1.13         (acg      01-Feb-11):             m_timed_out = true;
1.13         (acg      01-Feb-11):             m_event_list_p->remove_dynamic( this, e ); 
1.1          (acg      15-Dec-06):             m_event_list_p->auto_delete();
1.13         (acg      01-Feb-11):             m_event_list_p = 0; 
1.1          (acg      15-Dec-06):             m_trigger_type = STATIC;
1.13         (acg      01-Feb-11): 	}
1.13         (acg      01-Feb-11): 
1.13         (acg      01-Feb-11): 	else
1.13         (acg      01-Feb-11): 	{
1.1          (acg      15-Dec-06):             m_timeout_event_p->cancel();
1.1          (acg      15-Dec-06):             m_timeout_event_p->reset();
1.13         (acg      01-Feb-11): 	    m_event_list_p->remove_dynamic( this, e ); 
1.13         (acg      01-Feb-11): 	    m_event_list_p->auto_delete();
1.13         (acg      01-Feb-11): 	    m_event_list_p = 0; 
1.13         (acg      01-Feb-11): 	    m_trigger_type = STATIC;
1.13         (acg      01-Feb-11): 	}
1.13         (acg      01-Feb-11): 	break;
1.13         (acg      01-Feb-11):       
1.13         (acg      01-Feb-11):       case AND_LIST_TIMEOUT:
1.13         (acg      01-Feb-11):         if ( e == m_timeout_event_p )
1.13         (acg      01-Feb-11): 	{
1.1          (acg      15-Dec-06):             m_timed_out = true;
1.13         (acg      01-Feb-11):             m_event_list_p->remove_dynamic( this, e ); 
1.1          (acg      15-Dec-06):             m_event_list_p->auto_delete();
1.13         (acg      01-Feb-11):             m_event_list_p = 0; 
1.1          (acg      15-Dec-06):             m_trigger_type = STATIC;
1.13         (acg      01-Feb-11): 	}
1.13         (acg      01-Feb-11): 
1.13         (acg      01-Feb-11): 	else
1.13         (acg      01-Feb-11): 	{
1.13         (acg      01-Feb-11): 	    -- m_event_count;
1.13         (acg      01-Feb-11): 	    if ( m_event_count == 0 )
1.13         (acg      01-Feb-11): 	    {
1.13         (acg      01-Feb-11): 		m_timeout_event_p->cancel();
1.13         (acg      01-Feb-11): 		m_timeout_event_p->reset();
1.13         (acg      01-Feb-11): 		// no need to remove_dynamic
1.13         (acg      01-Feb-11): 		m_event_list_p->auto_delete();
1.13         (acg      01-Feb-11): 		m_event_list_p = 0; 
1.13         (acg      01-Feb-11): 		m_trigger_type = STATIC;
1.13         (acg      01-Feb-11): 	    }
1.24         (acg      16-Feb-11): 	    else
1.24         (acg      16-Feb-11): 	    {
1.25         (acg      17-Feb-11): 	        return true;
1.24         (acg      16-Feb-11): 	    }
1.13         (acg      01-Feb-11): 	}
1.13         (acg      01-Feb-11): 	break;
1.13         (acg      01-Feb-11): 
1.13         (acg      01-Feb-11):       case STATIC: {
1.39         (acg      01-Apr-11):         // we should never get here, but throw_it() can make it happen.
1.39         (acg      01-Apr-11): 	SC_REPORT_WARNING(SC_NOT_EXPECTING_DYNAMIC_EVENT_NOTIFY_, name());
1.39         (acg      01-Apr-11):         return true;
1.13         (acg      01-Feb-11):       }
1.1          (acg      15-Dec-06):     }
1.25         (acg      17-Feb-11): 
1.27         (acg      19-Feb-11):     // If we get here then the thread is has satisfied its wait criteria, if 
1.27         (acg      19-Feb-11):     // its suspended mark its state as ready to run. If its not suspended then 
1.25         (acg      17-Feb-11):     // push it onto the runnable queue.
1.25         (acg      17-Feb-11): 
1.25         (acg      17-Feb-11):     if ( (m_state & ps_bit_suspended) )
1.25         (acg      17-Feb-11):     {
1.25         (acg      17-Feb-11): 	m_state = m_state | ps_bit_ready_to_run;
1.25         (acg      17-Feb-11):     }
1.25         (acg      17-Feb-11):     else
1.25         (acg      17-Feb-11):     {
1.25         (acg      17-Feb-11):         simcontext()->push_runnable_thread(this);
1.25         (acg      17-Feb-11):     }
1.25         (acg      17-Feb-11): 
1.25         (acg      17-Feb-11):     return true;
1.1          (acg      15-Dec-06): }
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): 
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): //"sc_set_stack_size"
1.1          (acg      15-Dec-06): //
1.1          (acg      15-Dec-06): //------------------------------------------------------------------------------
1.1          (acg      15-Dec-06): void
1.1          (acg      15-Dec-06): sc_set_stack_size( sc_thread_handle thread_h, std::size_t size )
1.1          (acg      15-Dec-06): {
1.1          (acg      15-Dec-06):     thread_h->set_stack_size( size );
1.1          (acg      15-Dec-06): }
1.1          (acg      15-Dec-06): 
1.43         (acg      10-Apr-11): #undef DEBUG_MSG
1.44         (acg      11-Apr-11): #undef DEBUG_NAME
1.43         (acg      10-Apr-11): 
1.1          (acg      15-Dec-06): } // namespace sc_core 
